function XHldata()
//{data for X_H(l)}

k:=12;//weight
l:=41;//level

//==== equation for X_H(l)===
X:=[0, 1, -2, 0, 1, 5, -4, 0, -3, 0, 0, 0, 0, 0, -1, 0, -1, 0, -2, 3];
Y:=[0, -5, 8, 2, -1, -19, 20, -7, 15, -1, -1, -1, 1, 1, 0, 1, 0, 1, 15, -15];

R<x,y>:=PolynomialRing(Rationals(),2);

XHl :=x^5*y^6+(5*x^5+1-5*x+5*x^2-x^3+7*x^4)*y^5+x*(5*x^4+18*x^3+6*x^2+18*x-7)*y^4+x*(x^4-6*x^3+6*x+1)*y^3+x*(7*x^4+18*x^3-6*x^2+18*x-5)*y^2+x*(-x^5-5*x^4-5*x^3-x^2-7*x+5)*y-x;


//==== two generators of each cusp of XHl computed using function RationalCuspsOfXHl.m ====
genx1:=x; 
geny1:=x^5*y + 1;
genx2:=x; 
geny2:=614/11*x^5/(x^14 + 5*x^13 - 5*x^12 - 55*x^11 - 87*x^10 - 116*x^9 - 190*x^8 - 
    190*x^6 + 116*x^5 - 87*x^4 + 55*x^3 - 5*x^2 - 5*x + 1)*y^5 + (70802/209*x^19 
    + 957283/627*x^18 - 1617020/627*x^17 - 3774847/209*x^16 - 12613015/627*x^15 -
    4590948/209*x^14 - 437650/11*x^13 + 1290272/33*x^12 - 579336/11*x^11 + 
    1418462/19*x^10 - 24019684/627*x^9 + 6391565/209*x^8 - 1526994/209*x^7 - 
    1593365/627*x^6 + 754001/627*x^5 + 4298/11*x^4 - 614/11*x^3 + 3070/11*x^2 - 
    3070/11*x + 614/11)/(x^14 + 5*x^13 - 5*x^12 - 55*x^11 - 87*x^10 - 116*x^9 - 
    190*x^8 - 190*x^6 + 116*x^5 - 87*x^4 + 55*x^3 - 5*x^2 - 5*x + 1)*y^4 + 
    (202273/209*x^18 + 612737/209*x^17 - 2711922/209*x^16 - 8216295/209*x^15 + 
    944591/627*x^14 - 3602557/627*x^13 + 34546220/627*x^12 + 237301742/627*x^11 -
    46809073/209*x^10 + 181494138/209*x^9 - 465208631/627*x^8 + 551350889/627*x^7
    - 442740884/627*x^6 + 259552853/627*x^5 - 45507221/209*x^4 + 11247919/209*x^3
    + 6910862/627*x^2 - 1577802/209*x + 579011/627)/(x^14 + 5*x^13 - 5*x^12 - 
    55*x^11 - 87*x^10 - 116*x^9 - 190*x^8 - 190*x^6 + 116*x^5 - 87*x^4 + 55*x^3 -
    5*x^2 - 5*x + 1)*y^3 + (-2359670/209*x^18 - 38362624/627*x^17 + 
    912413/33*x^16 + 129247678/209*x^15 + 793796983/627*x^14 + 419841690/209*x^13
    + 1986501481/627*x^12 + 951797095/627*x^11 + 103821730/33*x^10 - 
    74918104/209*x^9 + 43843724/33*x^8 - 146960488/209*x^7 + 5684557/57*x^6 - 
    66409696/627*x^5 - 18164869/627*x^4 + 9849936/209*x^3 - 2673527/627*x^2 - 
    584989/209*x + 274240/627)/(x^14 + 5*x^13 - 5*x^12 - 55*x^11 - 87*x^10 - 
    116*x^9 - 190*x^8 - 190*x^6 + 116*x^5 - 87*x^4 + 55*x^3 - 5*x^2 - 5*x + 
    1)*y^2 + (-x^19 - 2626511/627*x^18 - 40797698/627*x^17 - 42422861/209*x^16 + 
    244898432/627*x^15 + 1630340017/627*x^14 + 273258184/57*x^13 + 
    94254986/11*x^12 + 7436440730/627*x^11 + 1117261831/209*x^10 + 
    3079352025/209*x^9 - 4259539675/627*x^8 + 11683960*x^7 - 188588503/19*x^6 + 
    3476420638/627*x^5 - 714662687/209*x^4 + 600637528/627*x^3 + 94408456/627*x^2
    - 71630060/627*x + 8713975/627)/(x^14 + 5*x^13 - 5*x^12 - 55*x^11 - 87*x^10 -
    116*x^9 - 190*x^8 - 190*x^6 + 116*x^5 - 87*x^4 + 55*x^3 - 5*x^2 - 5*x + 1)*y 
    + (x^14 + 218/33*x^13 + 37/11*x^12 - 2104/33*x^11 - 2066/11*x^10 - 
    8380/33*x^9 - 2938/11*x^8 - 6956/33*x^7 - 2378/11*x^6 - 2830/33*x^5 - 
    4535/11*x^4 + 1610/33*x^3 - 3617/11*x^2 + 322/3*x)/(x^14 + 5*x^13 - 5*x^12 - 
    55*x^11 - 87*x^10 - 116*x^9 - 190*x^8 - 190*x^6 + 116*x^5 - 87*x^4 + 55*x^3 -
    5*x^2 - 5*x + 1); 
genx3:=1/x; 
geny3:=1/x*y^5 + 5/x*y^4 + 5/x*y^3 + 1/x*y^2 + 7/x*y + 1/x;
genx4:=1/x; 
geny4:=-1/x*y^5 - 4/x*y^4 - 5/x*y^3 - 1/x*y^2 - 7/x*y + 1;


CuspsOfXHl:=[[genx1,geny1],[genx2,geny2],[genx3,geny3],[genx4,geny4]];

//==correspondences between cusps of XH1 represented by two different ways computed using function FindCuspsCorr.m ==

//CorrOfCusps:=[[ 16, 10, 4, 18, 1 ],[ 14, 19, 17, 15, 6 ],[ 2, 9, 20, 8, 5 ],[ 12, 13, 3, 7, 11 ]];


return <<XHl,X,Y,CuspsOfXHl>,<k,l>>;

end function;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function PolyXxXyYxYy()
//{polynomial relations of (X,x),(X,y),(Y,x) and (Y,y)}

R1<X,x>:=PolynomialRing(Rationals(),2);

PolyXx:=-39*(-X)*x^12+109*(-X)*x^13+(-X)*x^22-6*(-X)*x^21+15*(-X)*x^20-21*(-X)*x^19+20*(-X)*x^18-7*(-X)*x^17-41*(-X)*x^16+119*(-X)*x^15-155*(-X)*x^14-36*(-X)^2*x^12+121*(-X)^2*x^13+14*(-X)^2*x^22-62*(-X)^2*x^21+136*(-X)^2*x^20-181*(-X)^2*x^19+175*(-X)^2*x^18-108*(-X)^2*x^17-64*(-X)^2*x^16+252*(-X)^2*x^15-260*(-X)^2*x^14+33*(-X)^2*x^11-23*(-X)^2*x^10-(-X)^2*x^23-25*(-X)^3*x^9-141*(-X)^3*x^12-489*(-X)^3*x^13+87*(-X)^3*x^22-254*(-X)^3*x^21+400*(-X)^3*x^20-429*(-X)^3*x^19+410*(-X)^3*x^18-255*(-X)^3*x^17-46*(-X)^3*x^16-31*(-X)^3*x^15+511*(-X)^3*x^14+428*(-X)^3*x^11-179*(-X)^3*x^10+31*(-X)^3*x^8-12*(-X)^3*x^23-494*(-X)^4*x^9-1963*(-X)^4*x^12-9*(-X)^4*x^13+297*(-X)^4*x^22-512*(-X)^4*x^21+303*(-X)^4*x^20+63*(-X)^4*x^19+16*(-X)^4*x^17-214*(-X)^4*x^16-600*(-X)^4*x^15+1439*(-X)^4*x^14+1532*(-X)^4*x^11+23*(-X)^4*x^10+210*(-X)^4*x^8+8*(-X)^4*x^24-(-X)^4*x^25-73*(-X)^4*x^23-698*(-X)^5*x^9-3211*(-X)^5*x^12-44*(-X)^5*x^5+3225*(-X)^5*x^13+125*(-X)^5*x^6+393*(-X)^5*x^22-189*(-X)^5*x^21-626*(-X)^5*x^20+793*(-X)^5*x^19+181*(-X)^5*x^18-713*(-X)^5*x^17+1041*(-X)^5*x^16-2036*(-X)^5*x^15+612*(-X)^5*x^14-650*(-X)^5*x^11+2088*(-X)^5*x^10-89*(-X)^5*x^8-65*(-X)^5*x^7+28*(-X)^5*x^24+5*(-X)^5*x^25-5*(-X)^5*x^26+(-X)^5*x^27-171*(-X)^5*x^23+4778*(-X)^6*x^9+3308*(-X)^6*x^12+6*(-X)^6*x^2-7*(-X)^6*x^3-204*(-X)^6*x^5+3867*(-X)^6*x^13+995*(-X)^6*x^6-364*(-X)^6*x^22+1258*(-X)^6*x^21-1427*(-X)^6*x^20-813*(-X)^6*x^19+2923*(-X)^6*x^18-2208*(-X)^6*x^17+2680*(-X)^6*x^16-3724*(-X)^6*x^15-1041*(-X)^6*x^14-7145*(-X)^6*x^11+77*(-X)^6*x^10-1779*(-X)^6*x^8-1205*(-X)^6*x^7-14*(-X)^6*x^24+59*(-X)^6*x^25-48*(-X)^6*x^26+14*(-X)^6*x^27-(-X)^6*x^28+16*(-X)^6*x^23+9023*(-X)^7*x^9+4718*(-X)^7*x^12+44*(-X)^7*x^2-52*(-X)^7*x^4-104*(-X)^7*x^3+213*(-X)^7*x^5+4033*(-X)^7*x^13+1517*(-X)^7*x^6-611*(-X)^7*x^22+510*(-X)^7*x^21+391*(-X)^7*x^20-2546*(-X)^7*x^19+1983*(-X)^7*x^18+2825*(-X)^7*x^17-3346*(-X)^7*x^16+906*(-X)^7*x^15-4631*(-X)^7*x^14-1325*(-X)^7*x^11-10919*(-X)^7*x^10+1866*(-X)^7*x^8-4787*(-X)^7*x^7-32*(-X)^7*x^24+59*(-X)^7*x^25-117*(-X)^7*x^26+54*(-X)^7*x^27-7*(-X)^7*x^28-6*x^12+492*(-X)^14*x^5-4897*(-X)^14*x^13-181*(-X)^14*x^6-3842*(-X)^14*x^22+2385*(-X)^14*x^21+6781*(-X)^14*x^20-2343*(-X)^14*x^19-10345*(-X)^14*x^18+1497*(-X)^14*x^17+12640*(-X)^14*x^16-2316*(-X)^14*x^15-7179*(-X)^14*x^14+3484*(-X)^14*x^11-9428*(-X)^14*x^10+2970*(-X)^14*x^8-1880*(-X)^14*x^7-664*(-X)^13*x^24-203*(-X)^13*x^25+363*(-X)^13*x^26-231*(-X)^13*x^27+81*(-X)^13*x^28-10*(-X)^13*x^29+127*(-X)^13*x^23+2390*(-X)^14*x^9+9568*(-X)^14*x^12-170*(-X)^14*x^4-265*(-X)^12*x^23+6971*(-X)^13*x^9-14383*(-X)^13*x^12-341*(-X)^13*x^4+135*(-X)^13*x^3-346*(-X)^13*x^5+20315*(-X)^13*x^13+2782*(-X)^13*x^6+3580*(-X)^13*x^22-2322*(-X)^13*x^21-5034*(-X)^13*x^20+203*(-X)^13*x^19+11015*(-X)^13*x^18-1780*(-X)^13*x^17-10018*(-X)^13*x^16+615*(-X)^13*x^15-1751*(-X)^13*x^14-6561*(-X)^13*x^11+4375*(-X)^13*x^10-4166*(-X)^13*x^8-2737*(-X)^13*x^7+430*(-X)^12*x^24+672*(-X)^12*x^25-167*(-X)^12*x^26-65*(-X)^12*x^27-9*(-X)^12*x^28+11*(-X)^12*x^29-(-X)^12*x^30+580*(-X)^12*x^4+107*(-X)^12*x^3-2369*(-X)^12*x^5-20912*(-X)^12*x^13+1436*(-X)^12*x^6-5332*(-X)^12*x^22+3828*(-X)^12*x^21+5902*(-X)^12*x^20+788*(-X)^12*x^19-6652*(-X)^12*x^18-15743*(-X)^12*x^17+24295*(-X)^12*x^16-8574*(-X)^12*x^15+16471*(-X)^12*x^14+24018*(-X)^12*x^11+1049*(-X)^12*x^10-2380*(-X)^12*x^8+4176*(-X)^12*x^7-2292*(-X)^11*x^23-9390*(-X)^12*x^9-11851*(-X)^12*x^12-59*(-X)^12*x^2-7*(-X)^11*x^24-328*(-X)^11*x^25+384*(-X)^11*x^26-55*(-X)^11*x^27-18*(-X)^11*x^28+3*(-X)^11*x^29+534*(-X)^10*x^23+11*(-X)^11*x+2253*(-X)^11*x^9+19898*(-X)^11*x^12+3*(-X)^11*x^2+1030*(-X)^11*x^4-335*(-X)^11*x^3-273*(-X)^11*x^5-9650*(-X)^11*x^13-1954*(-X)^11*x^6+3753*(-X)^11*x^22+2228*(-X)^11*x^21-4659*(-X)^11*x^20+2160*(-X)^11*x^19-14312*(-X)^11*x^18+21492*(-X)^11*x^17-4439*(-X)^11*x^16+1709*(-X)^11*x^15-10163*(-X)^11*x^14+9258*(-X)^11*x^11-22835*(-X)^11*x^10+8604*(-X)^11*x^8-1465*(-X)^11*x^7-1215*(-X)^10*x^24+421*(-X)^10*x^25+87*(-X)^10*x^26-50*(-X)^10*x^27-5*(-X)^10*x^28+3*(-X)^10*x^29+11419*(-X)^10*x^18-3588*(-X)^10*x^17+7906*(-X)^10*x^16-6753*(-X)^10*x^15-8872*(-X)^10*x^14-9777*(-X)^10*x^11-6985*(-X)^10*x^10-1424*(-X)^10*x^8-5195*(-X)^10*x^7+592*(-X)^9*x^23+11593*(-X)^10*x^9+9735*(-X)^10*x^12+68*(-X)^10*x^2+258*(-X)^10*x^4-193*(-X)^10*x^3-934*(-X)^10*x^5+8108*(-X)^10*x^13+3543*(-X)^10*x^6+772*(-X)^10*x^22-1163*(-X)^10*x^21+6250*(-X)^10*x^20-14536*(-X)^10*x^19-370*(-X)^9*x^24-316*(-X)^9*x^25+225*(-X)^9*x^26+16*(-X)^9*x^27-29*(-X)^9*x^28+4*(-X)^9*x^29+157*(-X)^8*x^23+3370*(-X)^9*x^9-7002*(-X)^9*x^12+29*(-X)^9*x^2+1274*(-X)^9*x^4-315*(-X)^9*x^3-1987*(-X)^9*x^5+10417*(-X)^9*x^13-50*(-X)^9*x^6-728*(-X)^9*x^22+4931*(-X)^9*x^21-8816*(-X)^9*x^20+4092*(-X)^9*x^19-926*(-X)^9*x^18+4640*(-X)^9*x^17+2332*(-X)^9*x^16-12819*(-X)^9*x^15+3102*(-X)^9*x^14+710*(-X)^9*x^11-1271*(-X)^9*x^10-5115*(-X)^9*x^8+4011*(-X)^9*x^7+72*(-X)^8*x^24-298*(-X)^8*x^25+33*(-X)^8*x^26+69*(-X)^8*x^27-21*(-X)^8*x^28+(-X)^8*x^29-4434*(-X)^8*x^15+5832*(-X)^8*x^14+4734*(-X)^8*x^11-6931*(-X)^8*x^10+8046*(-X)^8*x^8-2267*(-X)^8*x^7+340*(-X)^7*x^23-3277*(-X)^8*x^9+4960*(-X)^8*x^12+81*(-X)^8*x^2+424*(-X)^8*x^4-360*(-X)^8*x^3+852*(-X)^8*x^5-7180*(-X)^8*x^13-1899*(-X)^8*x^6+1112*(-X)^8*x^22-2106*(-X)^8*x^21+947*(-X)^8*x^20-15*(-X)^8*x^19-851*(-X)^8*x^18+2435*(-X)^8*x^17-111*(-X)^8*x^16+5*x^11*(-X)+8*x^15*(-X)^21-x^11*(-X)^20+6*x^10*(-X)^19-15*x^9*(-X)^18+6*x^5*(-X)^16-8*(-X)^21*x^23-7*(-X)^22*x^22+21*(-X)^22*x^21-35*(-X)^22*x^20+35*(-X)^22*x^19-21*(-X)^22*x^18+7*(-X)^22*x^17-15*x^4*(-X)^15-x^6*(-X)^17+20*x^3*(-X)^14-15*x^2*(-X)^13+6*x*(-X)^12+47*(-X)^20*x^23+48*(-X)^21*x^22-112*(-X)^21*x^21+112*(-X)^21*x^20-112*(-X)^21*x^18+112*(-X)^21*x^17-48*(-X)^21*x^16-4*(-X)^20*x^24+344*(-X)^20*x^18+39*(-X)^20*x^17-222*(-X)^20*x^16+108*(-X)^20*x^15+7*(-X)^20*x^14-210*(-X)^19*x^23+7*(-X)^20*x^12-21*(-X)^20*x^13-171*(-X)^20*x^22+238*(-X)^20*x^21+7*(-X)^20*x^20-378*(-X)^20*x^19+71*(-X)^19*x^24-51*(-X)^19*x^25+31*(-X)^19*x^26-9*(-X)^19*x^27+(-X)^19*x^28+240*(-X)^18*x^23+77*(-X)^19*x^12-13*(-X)^19*x^13+452*(-X)^19*x^22-313*(-X)^19*x^21-332*(-X)^19*x^20+457*(-X)^19*x^19+422*(-X)^19*x^18-985*(-X)^19*x^17+417*(-X)^19*x^16+247*(-X)^19*x^15-233*(-X)^19*x^14-35*(-X)^19*x^11-16*(-X)^17*x^23+96*(-X)^18*x^12-97*(-X)^18*x^13-566*(-X)^18*x^22-138*(-X)^18*x^21+1208*(-X)^18*x^20-575*(-X)^18*x^19-940*(-X)^18*x^18+731*(-X)^18*x^17+800*(-X)^18*x^16-1320*(-X)^18*x^15+627*(-X)^18*x^14-143*(-X)^18*x^11+76*(-X)^18*x^10-42*(-X)^18*x^24+181*(-X)^18*x^25-179*(-X)^18*x^26+64*(-X)^18*x^27-8*(-X)^18*x^28+9*(-X)^17*x^7-529*(-X)^17*x^24-14*(-X)^17*x^25+343*(-X)^17*x^26-180*(-X)^17*x^27+31*(-X)^17*x^28-(-X)^17*x^29+425*(-X)^16*x^24-159*(-X)^16*x^25-337*(-X)^16*x^26+279*(-X)^16*x^27-74*(-X)^16*x^28+6*(-X)^16*x^29+690*(-X)^16*x^23-17*(-X)^17*x^9+923*(-X)^17*x^12-590*(-X)^17*x^13+806*(-X)^17*x^22+257*(-X)^17*x^21-1309*(-X)^17*x^20-410*(-X)^17*x^19+2844*(-X)^17*x^18-2405*(-X)^17*x^17-732*(-X)^17*x^16+2694*(-X)^17*x^15-1380*(-X)^17*x^14-439*(-X)^17*x^11+132*(-X)^17*x^10-16*(-X)^17*x^8+180*(-X)^15*x^23-230*(-X)^16*x^9-1833*(-X)^16*x^12+5498*(-X)^16*x^13-51*(-X)^16*x^6-2012*(-X)^16*x^22+1278*(-X)^16*x^21+872*(-X)^16*x^20-471*(-X)^16*x^19-3405*(-X)^16*x^18+3030*(-X)^16*x^17+4540*(-X)^16*x^16-6696*(-X)^16*x^15-1096*(-X)^16*x^14-1576*(-X)^16*x^11+1366*(-X)^16*x^10-215*(-X)^16*x^8+165*(-X)^16*x^7-170*(-X)^15*x^24-283*(-X)^15*x^25+342*(-X)^15*x^26-248*(-X)^15*x^27+87*(-X)^15*x^28-10*(-X)^15*x^29-695*(-X)^14*x^23-2347*(-X)^15*x^9-9275*(-X)^15*x^12+125*(-X)^15*x^5-1271*(-X)^15*x^13-393*(-X)^15*x^6+2126*(-X)^15*x^22-2123*(-X)^15*x^21-4351*(-X)^15*x^20+4485*(-X)^15*x^19+6111*(-X)^15*x^18-4750*(-X)^15*x^17-9091*(-X)^15*x^16+6910*(-X)^15*x^15+5333*(-X)^15*x^14+7398*(-X)^15*x^11+53*(-X)^15*x^10+777*(-X)^15*x^8+400*(-X)^15*x^7+959*(-X)^14*x^24+471*(-X)^14*x^25-576*(-X)^14*x^26+257*(-X)^14*x^27-69*(-X)^14*x^28+7*(-X)^14*x^29+(-X)^22*x^23+15*x^13+x^17-6*x^16+15*x^15-20*x^14+x^11-(-X)^11-7*x*(-X)^10-x*(-X)^9-5*x*(-X)^8-5*x*(-X)^7-x*(-X)^6+5*x^4*(-X)^5-25*x^7*(-X)^4-6*x^7*(-X)^3+5*x^9*(-X)^2-x^16*(-X)^22;

R2<X,y>:=PolynomialRing(Rationals(),2);

PolyXy:=-32*(-X)*y^15+96*(-X)*y^16-177*(-X)*y^17+215*(-X)*y^18-170*(-X)*y^19+82*(-X)*y^20-21*(-X)*y^21+2*(-X)*y^22+y^16-5*y^17+10*y^18-10*y^19+5*y^20-y^21-33*y*(-X)^18-37*y*(-X)^17-28*y*(-X)^16-9*y*(-X)^15-9*y^11*(-X)^3-y*(-X)^14+4*y^5*(-X)^9-5*y^10*(-X)^4+24*y^6*(-X)^8+2*y^3*(-X)^12+y^6*(-X)^6+56*y^4*(-X)^11+5*y^14*(-X)-5*y*(-X)^21-17*y*(-X)^20-y^11*(-X)^2+5*y^4*(-X)^10+9*y^6*(-X)^7-y^8*(-X)^5-3*y^2*(-X)^13-40*y*(-X)^19-6*y*(-X)^22-293930*(-X)^23*y^12+352716*(-X)^23*y^11-352716*(-X)^23*y^10+203490*(-X)^23*y^13-116280*(-X)^23*y^14-203490*(-X)^23*y^8+54264*(-X)^23*y^15-20349*(-X)^23*y^16+5985*(-X)^23*y^17-1330*(-X)^23*y^18+210*(-X)^23*y^19-21*(-X)^23*y^20+(-X)^23*y^21+21*(-X)^23*y-210*(-X)^23*y^2-54264*(-X)^23*y^6+116280*(-X)^23*y^7+1330*(-X)^23*y^3-5985*(-X)^23*y^4+20349*(-X)^23*y^5+293930*(-X)^23*y^9+638248*(-X)^22*y^12-772616*(-X)^22*y^11+755820*(-X)^22*y^10-419900*(-X)^22*y^13+213180*(-X)^22*y^14+387600*(-X)^22*y^8-77520*(-X)^22*y^15+15504*(-X)^22*y^16+1938*(-X)^22*y^17-2850*(-X)^22*y^18+1140*(-X)^22*y^19-260*(-X)^22*y^20+34*(-X)^22*y^21-2*(-X)^22*y^22+118*(-X)^22*y^2+83334*(-X)^22*y^6-201552*(-X)^22*y^7-1100*(-X)^22*y^3+6460*(-X)^22*y^4-26790*(-X)^22*y^5-600780*(-X)^22*y^9+(-X)^21*y^23-200174*(-X)^21*y^12+238732*(-X)^21*y^11-195924*(-X)^21*y^10+101712*(-X)^21*y^13-4844*(-X)^21*y^14-31500*(-X)^21*y^8-44386*(-X)^21*y^15+45748*(-X)^21*y^16-26757*(-X)^21*y^17+10274*(-X)^21*y^18-2512*(-X)^21*y^19+307*(-X)^21*y^20+14*(-X)^21*y^21-10*(-X)^21*y^22+82*(-X)^21*y^2+12886*(-X)^21*y^6-6391*(-X)^21*y^7-612*(-X)^21*y^3+2707*(-X)^21*y^4-7622*(-X)^21*y^5+108274*(-X)^21*y^9+(-X)^20*y^26-23*(-X)^20*y^25+248*(-X)^20*y^24-1662*(-X)^20*y^23+1378582*(-X)^20*y^12-1843570*(-X)^20*y^11+1865433*(-X)^20*y^10-709216*(-X)^20*y^13+182134*(-X)^20*y^14+948702*(-X)^20*y^8+19926*(-X)^20*y^15+26018*(-X)^20*y^16-126517*(-X)^20*y^17+158851*(-X)^20*y^18-121414*(-X)^20*y^19+65494*(-X)^20*y^20-26079*(-X)^20*y^21+7714*(-X)^20*y^22+315*(-X)^20*y^2+200272*(-X)^20*y^6-487344*(-X)^20*y^7-2800*(-X)^20*y^3+15900*(-X)^20*y^4-64705*(-X)^20*y^5-1486243*(-X)^20*y^9+662*(-X)^19*y^2+185500*(-X)^19*y^6-334723*(-X)^19*y^7-5093*(-X)^19*y^3+24109*(-X)^19*y^4-78373*(-X)^19*y^5-688248*(-X)^19*y^9-2*(-X)^19*y^27+38*(-X)^19*y^26-320*(-X)^19*y^25+1511*(-X)^19*y^24-3885*(-X)^19*y^23+2532759*(-X)^19*y^12-1719578*(-X)^19*y^11+1054389*(-X)^19*y^10-3009694*(-X)^19*y^13+2710555*(-X)^19*y^14+494344*(-X)^19*y^8-1701504*(-X)^19*y^15+541629*(-X)^19*y^16+211776*(-X)^19*y^17-416797*(-X)^19*y^18+297073*(-X)^19*y^19-126192*(-X)^19*y^20+28451*(-X)^19*y^21+1653*(-X)^19*y^22+189432*(-X)^18*y^21-97246*(-X)^18*y^22+492*(-X)^18*y^2+175369*(-X)^18*y^6-433654*(-X)^18*y^7-3526*(-X)^18*y^3+16616*(-X)^18*y^4-59567*(-X)^18*y^5-1475228*(-X)^18*y^9+(-X)^18*y^28-9*(-X)^18*y^27-36*(-X)^18*y^26+1006*(-X)^18*y^25-7600*(-X)^18*y^24+33419*(-X)^18*y^23+1653013*(-X)^18*y^12-1992589*(-X)^18*y^11+1937594*(-X)^18*y^10-1307359*(-X)^18*y^13+1316943*(-X)^18*y^14+889159*(-X)^18*y^8-1573311*(-X)^18*y^15+1619607*(-X)^18*y^16-1199371*(-X)^18*y^17+524756*(-X)^18*y^18+8694*(-X)^18*y^19-216572*(-X)^18*y^20-4261856*(-X)^17*y^11+2102088*(-X)^17*y^10-6830653*(-X)^17*y^13+5248102*(-X)^17*y^14+197651*(-X)^17*y^8-2479532*(-X)^17*y^15+204938*(-X)^17*y^16+629221*(-X)^17*y^17-357607*(-X)^17*y^18-138444*(-X)^17*y^19+337268*(-X)^17*y^20-259231*(-X)^17*y^21+117798*(-X)^17*y^22+534*(-X)^17*y^2+53702*(-X)^17*y^6-74831*(-X)^17*y^7-3485*(-X)^17*y^3+13393*(-X)^17*y^4-32902*(-X)^17*y^5-738389*(-X)^17*y^9-5*(-X)^17*y^28+75*(-X)^17*y^27-441*(-X)^17*y^26+903*(-X)^17*y^25+3513*(-X)^17*y^24-32151*(-X)^17*y^23+6300378*(-X)^17*y^12+2754027*(-X)^16*y^12-1841694*(-X)^16*y^11+1204640*(-X)^16*y^10-3969724*(-X)^16*y^13+5015246*(-X)^16*y^14+347096*(-X)^16*y^8-5022661*(-X)^16*y^15+3552726*(-X)^16*y^16-1227312*(-X)^16*y^17-719871*(-X)^16*y^18+1507990*(-X)^16*y^19-1290161*(-X)^16*y^20+712269*(-X)^16*y^21-262528*(-X)^16*y^22+345*(-X)^16*y^2+47874*(-X)^16*y^6-137231*(-X)^16*y^7-1899*(-X)^16*y^3+6464*(-X)^16*y^4-17418*(-X)^16*y^5-710708*(-X)^16*y^9-(-X)^16*y^29+28*(-X)^16*y^28-301*(-X)^16*y^27+1678*(-X)^16*y^26-4750*(-X)^16*y^25+484*(-X)^16*y^24+55420*(-X)^16*y^23+25387*(-X)^15*y^25-66297*(-X)^15*y^24+103581*(-X)^15*y^23+4677914*(-X)^15*y^12-3720340*(-X)^15*y^11+2160172*(-X)^15*y^10-4341946*(-X)^15*y^13+3026360*(-X)^15*y^14+187815*(-X)^15*y^8-1888530*(-X)^15*y^15+1751310*(-X)^15*y^16-2292869*(-X)^15*y^17+2566087*(-X)^15*y^18-2083420*(-X)^15*y^19+1158891*(-X)^15*y^20-367386*(-X)^15*y^21-23241*(-X)^15*y^22+57*(-X)^15*y^2-37583*(-X)^15*y^6+23571*(-X)^15*y^7+173*(-X)^15*y^3-3139*(-X)^15*y^4+15305*(-X)^15*y^5-866359*(-X)^15*y^9+5*(-X)^15*y^29-110*(-X)^15*y^28+1093*(-X)^15*y^27-6492*(-X)^15*y^26-5*(-X)^14*y^29+102*(-X)^14*y^28-938*(-X)^14*y^27+5122*(-X)^14*y^26-17997*(-X)^14*y^25+39017*(-X)^14*y^24-30904*(-X)^14*y^23+2802953*(-X)^14*y^12-1690347*(-X)^14*y^11+895802*(-X)^14*y^10-4001991*(-X)^14*y^13+4642192*(-X)^14*y^14+126553*(-X)^14*y^8-4013357*(-X)^14*y^15+2091733*(-X)^14*y^16+193816*(-X)^14*y^17-1674291*(-X)^14*y^18+1893707*(-X)^14*y^19-1284247*(-X)^14*y^20+558719*(-X)^14*y^21-118268*(-X)^14*y^22-12*(-X)^14*y^2-10221*(-X)^14*y^6-15196*(-X)^14*y^7+311*(-X)^14*y^3-2131*(-X)^14*y^4+7104*(-X)^14*y^5-397225*(-X)^14*y^9+3*(-X)^13*y^29-73*(-X)^13*y^28+801*(-X)^13*y^27-5399*(-X)^13*y^26+25144*(-X)^13*y^25-84825*(-X)^13*y^24+207827*(-X)^13*y^23+478289*(-X)^13*y^12-756348*(-X)^13*y^11+784793*(-X)^13*y^10-425143*(-X)^13*y^13+1214579*(-X)^13*y^14+278238*(-X)^13*y^8-2832994*(-X)^13*y^15+4336007*(-X)^13*y^16-4616678*(-X)^13*y^17+3468329*(-X)^13*y^18-1708224*(-X)^13*y^19+323834*(-X)^13*y^20+292903*(-X)^13*y^21-348615*(-X)^13*y^22+24412*(-X)^13*y^6-100079*(-X)^13*y^7+57*(-X)^13*y^3+2*(-X)^13*y^4-3287*(-X)^13*y^5-553550*(-X)^13*y^9+18*(-X)^12*y^29-152*(-X)^12*y^28+810*(-X)^12*y^27-3046*(-X)^12*y^26+8450*(-X)^12*y^25-17543*(-X)^12*y^24+27063*(-X)^12*y^23-(-X)^12*y^30+399108*(-X)^12*y^12-421517*(-X)^12*y^11+370376*(-X)^12*y^10-413588*(-X)^12*y^13+582848*(-X)^12*y^14+127663*(-X)^12*y^8-854456*(-X)^12*y^15+1011349*(-X)^12*y^16-901339*(-X)^12*y^17+595832*(-X)^12*y^18-284539*(-X)^12*y^19+85425*(-X)^12*y^20+2754*(-X)^12*y^21-28143*(-X)^12*y^22+13780*(-X)^12*y^6-49161*(-X)^12*y^7+216*(-X)^12*y^4-2519*(-X)^12*y^5-249690*(-X)^12*y^9+3*(-X)^11*y^29-42*(-X)^11*y^28+280*(-X)^11*y^27-1317*(-X)^11*y^26+5526*(-X)^11*y^25-21484*(-X)^11*y^24+69570*(-X)^11*y^23-383173*(-X)^11*y^12+340156*(-X)^11*y^11-172341*(-X)^11*y^10+23419*(-X)^11*y^13+837635*(-X)^11*y^14-6124*(-X)^11*y^8-1837519*(-X)^11*y^15+2325877*(-X)^11*y^16-1957882*(-X)^11*y^17+1034162*(-X)^11*y^18-173898*(-X)^11*y^19-248892*(-X)^11*y^20+284381*(-X)^11*y^21-169737*(-X)^11*y^22+1908*(-X)^11*y^6-2923*(-X)^11*y^7-514*(-X)^11*y^5+52873*(-X)^11*y^9-278*(-X)^10*y^6+2737*(-X)^10*y^7-18*(-X)^10*y^5+51431*(-X)^10*y^9+5*(-X)^10*y^29-96*(-X)^10*y^28+857*(-X)^10*y^27-4719*(-X)^10*y^26+17800*(-X)^10*y^25-47819*(-X)^10*y^24+90255*(-X)^10*y^23-511991*(-X)^10*y^12+317561*(-X)^10*y^11-145668*(-X)^10*y^10+545983*(-X)^10*y^13-211726*(-X)^10*y^14-13976*(-X)^10*y^8-477935*(-X)^10*y^15+1192071*(-X)^10*y^16-1523143*(-X)^10*y^17+1330491*(-X)^10*y^18-817689*(-X)^10*y^19+308358*(-X)^10*y^20+1492*(-X)^10*y^21-103988*(-X)^10*y^22-54*(-X)^9*y^6+214*(-X)^9*y^7+2371*(-X)^9*y^9+5*(-X)^9*y^29-90*(-X)^9*y^28+725*(-X)^9*y^27-3469*(-X)^9*y^26+10948*(-X)^9*y^25-23431*(-X)^9*y^24+31361*(-X)^9*y^23-83599*(-X)^9*y^12+37591*(-X)^9*y^11-11278*(-X)^9*y^10+123887*(-X)^9*y^13-108420*(-X)^9*y^14-559*(-X)^9*y^8-332*(-X)^9*y^15+181656*(-X)^9*y^16-348963*(-X)^9*y^17+409470*(-X)^9*y^18-340082*(-X)^9*y^19+198020*(-X)^9*y^20-65093*(-X)^9*y^21-10882*(-X)^9*y^22-24937*(-X)^8*y^11+13253*(-X)^8*y^10-52780*(-X)^8*y^13+76268*(-X)^8*y^14+1598*(-X)^8*y^8-118381*(-X)^8*y^15+173773*(-X)^8*y^16-219183*(-X)^8*y^17+231952*(-X)^8*y^18-200964*(-X)^8*y^19+130651*(-X)^8*y^20-48452*(-X)^8*y^21-8729*(-X)^8*y^22-291*(-X)^8*y^7-5417*(-X)^8*y^9+(-X)^8*y^29-34*(-X)^8*y^28+383*(-X)^8*y^27-2278*(-X)^8*y^26+8307*(-X)^8*y^25-19303*(-X)^8*y^24+26374*(-X)^8*y^23+38165*(-X)^8*y^12-1895*(-X)^7*y^12-3939*(-X)^7*y^11+3222*(-X)^7*y^10+18898*(-X)^7*y^13-37110*(-X)^7*y^14+476*(-X)^7*y^8+28284*(-X)^7*y^15+31532*(-X)^7*y^16-132940*(-X)^7*y^17+223907*(-X)^7*y^18-239744*(-X)^7*y^19+166210*(-X)^7*y^20-60781*(-X)^7*y^21-9036*(-X)^7*y^22-97*(-X)^7*y^7-1477*(-X)^7*y^9-17*(-X)^7*y^28+260*(-X)^7*y^27-1780*(-X)^7*y^26+7159*(-X)^7*y^25-18171*(-X)^7*y^24+27030*(-X)^7*y^23-7*(-X)^6*y^28+121*(-X)^6*y^27-881*(-X)^6*y^26+3601*(-X)^6*y^25-8935*(-X)^6*y^24+12131*(-X)^6*y^23-10826*(-X)^6*y^12+2268*(-X)^6*y^11-145*(-X)^6*y^10+31088*(-X)^6*y^13-60724*(-X)^6*y^14+39*(-X)^6*y^8+82070*(-X)^6*y^15-65880*(-X)^6*y^16-1891*(-X)^6*y^17+86876*(-X)^6*y^18-126566*(-X)^6*y^19+98848*(-X)^6*y^20-41510*(-X)^6*y^21+409*(-X)^6*y^22-10*(-X)^6*y^7-76*(-X)^6*y^9-(-X)^5*y^28+26*(-X)^5*y^27-227*(-X)^5*y^26+992*(-X)^5*y^25-2396*(-X)^5*y^24+2643*(-X)^5*y^23-2984*(-X)^5*y^12+691*(-X)^5*y^11-96*(-X)^5*y^10+8658*(-X)^5*y^13-18314*(-X)^5*y^14+27772*(-X)^5*y^15-25729*(-X)^5*y^16+4484*(-X)^5*y^17+24434*(-X)^5*y^18-39190*(-X)^5*y^19+32502*(-X)^5*y^20-15694*(-X)^5*y^21+2421*(-X)^5*y^22+9*(-X)^5*y^9+2*(-X)^4*y^27-27*(-X)^4*y^26+141*(-X)^4*y^25-353*(-X)^4*y^24+283*(-X)^4*y^23-35*(-X)^4*y^12+30*(-X)^4*y^11-145*(-X)^4*y^13+717*(-X)^4*y^14-2386*(-X)^4*y^15+6434*(-X)^4*y^16-11993*(-X)^4*y^17+15088*(-X)^4*y^18-13381*(-X)^4*y^19+8715*(-X)^4*y^20-4025*(-X)^4*y^21+940*(-X)^4*y^22-(-X)^3*y^26+8*(-X)^3*y^25-23*(-X)^3*y^24+8*(-X)^3*y^23+90*(-X)^3*y^12-409*(-X)^3*y^13+1271*(-X)^3*y^14-3095*(-X)^3*y^15+5728*(-X)^3*y^16-7657*(-X)^3*y^17+7293*(-X)^3*y^18-5002*(-X)^3*y^19+2497*(-X)^3*y^20-884*(-X)^3*y^21+185*(-X)^3*y^22+10*(-X)^2*y^12-48*(-X)^2*y^13+189*(-X)^2*y^14-584*(-X)^2*y^15+1245*(-X)^2*y^16-1797*(-X)^2*y^17+1792*(-X)^2*y^18-1246*(-X)^2*y^19+587*(-X)^2*y^20-171*(-X)^2*y^21+25*(-X)^2*y^22-(-X)^2*y^23-(-X)^23;


R3<Y,x>:=PolynomialRing(Rationals(),2);

PolyYx:= 462*x^12-Y^7-462*x^13-11*x^17+55*x^16-165*x^15+330*x^14-330*x^11+65577*Y^3*x^13+93409*Y^3*x^17-134470*Y^3*x^16+150324*Y^3*x^15-118919*Y^3*x^14+74762*Y^3*x^11-4*Y^3*x^24+76*Y^3*x^23+3201*Y^3*x^21+26929*Y^3*x^19+70447*Y^3*x^9-5536*Y^3*x^7-4906*Y^3*x^5-641*Y^3*x^22-10780*Y^3*x^20-54348*Y^3*x^18-95313*Y^3*x^10-23634*Y^3*x^8+9932*Y^3*x^6+196065*Y^4*x^12-1641*Y^4*x^4+134*Y^4*x^3-90861*Y^4*x^13-290874*Y^4*x^17+307002*Y^4*x^16-244886*Y^4*x^15+131550*Y^4*x^14-324451*Y^4*x^11+124*Y^4*x^24-5*Y^4*x^25-1295*Y^4*x^23-29356*Y^4*x^21-150644*Y^4*x^19-147764*Y^4*x^9+40074*Y^4*x^7+9144*Y^4*x^5+7687*Y^4*x^22+77575*Y^4*x^20+229455*Y^4*x^18+303972*Y^4*x^10+6367*Y^4*x^8-27370*Y^4*x^6-657481*Y^5*x^12+1411*Y^5*x^4-122*Y^5*x^3+373205*Y^5*x^13+215302*Y^5*x^17-176194*Y^5*x^16+155763*Y^5*x^15-184791*Y^5*x^14+736830*Y^5*x^11-840*Y^5*x^24+44*Y^5*x^25+6994*Y^5*x^23+101478*Y^5*x^21+281104*Y^5*x^19+115826*Y^5*x^9-85225*Y^5*x^7-9679*Y^5*x^5-33423*Y^5*x^22-204784*Y^5*x^20-272882*Y^5*x^18-477049*Y^5*x^10+76160*Y^5*x^8+38346*Y^5*x^6+965612*Y^6*x^12-1531*Y^6*x^4+120*Y^6*x^3-688328*Y^6*x^13+23118*Y^6*x^17+252150*Y^6*x^16-453274*Y^6*x^15+510023*Y^6*x^14-936770*Y^6*x^11-856*Y^6*x^24+538*Y^6*x^25-87*Y^6*x^26+5*Y^6*x^27-6298*Y^6*x^23-108915*Y^6*x^21-53802*Y^6*x^19-48764*Y^6*x^9+107053*Y^6*x^7+10357*Y^6*x^5+40929*Y^6*x^22+144070*Y^6*x^20-82908*Y^6*x^18+504109*Y^6*x^10-133751*Y^6*x^8-42798*Y^6*x^6+11*Y^7*x-1444703*Y^7*x^12-51*Y^7*x^2+258*Y^7*x^4+129*Y^7*x^3+667481*Y^7*x^13+274367*Y^7*x^17-313881*Y^7*x^16+24698*Y^7*x^15+21932*Y^7*x^14+1363074*Y^7*x^11+18133*Y^7*x^24-5646*Y^7*x^25+1017*Y^7*x^26-99*Y^7*x^27+4*Y^7*x^28-31787*Y^7*x^23+35581*Y^7*x^21+36541*Y^7*x^19-86159*Y^7*x^9-136220*Y^7*x^7-6323*Y^7*x^5+17826*Y^7*x^22-66622*Y^7*x^20-80748*Y^7*x^18-569161*Y^7*x^10+239956*Y^7*x^8+40393*Y^7*x^6+2025152*Y^8*x^12+141*Y^8*x^2+1158*Y^8*x^4-617*Y^8*x^3+Y^8*x^29-1925427*Y^8*x^13+868427*Y^8*x^17-839927*Y^8*x^16+319128*Y^8*x^15+797964*Y^8*x^14-1028206*Y^8*x^11-40043*Y^8*x^24+15848*Y^8*x^25-3733*Y^8*x^26+520*Y^8*x^27-38*Y^8*x^28+50088*Y^8*x^23-156505*Y^8*x^21+85816*Y^8*x^19+369504*Y^8*x^9+89105*Y^8*x^7+1147*Y^8*x^5+15875*Y^8*x^22+189610*Y^8*x^20-552287*Y^8*x^18-12428*Y^8*x^10-251694*Y^8*x^8-18566*Y^8*x^6-871703*Y^9*x^12-51*Y^9*x^2-3047*Y^9*x^4+631*Y^9*x^3-4*Y^9*x^29+987242*Y^9*x^13+72278*Y^9*x^17-757714*Y^9*x^16+892013*Y^9*x^15-864735*Y^9*x^14+357297*Y^9*x^11+30079*Y^9*x^24-15792*Y^9*x^25+4800*Y^9*x^26-883*Y^9*x^27+91*Y^9*x^28-22317*Y^9*x^23+7231*Y^9*x^21-651159*Y^9*x^19-267497*Y^9*x^9-61470*Y^9*x^7+6199*Y^9*x^5-22939*Y^9*x^22+253979*Y^9*x^20+620046*Y^9*x^18+125468*Y^9*x^10+177389*Y^9*x^8+4569*Y^9*x^6+1243788*Y^10*x^12+64*Y^10*x^2+2365*Y^10*x^4-473*Y^10*x^3+2*Y^10*x^29-1387312*Y^10*x^13+236014*Y^10*x^17-1010984*Y^10*x^16+1053015*Y^10*x^15+169075*Y^10*x^14-220554*Y^10*x^11-26542*Y^10*x^24+9760*Y^10*x^25-2207*Y^10*x^26+335*Y^10*x^27-35*Y^10*x^28+35530*Y^10*x^23-129973*Y^10*x^21-316812*Y^10*x^19+379995*Y^10*x^9-1986*Y^10*x^7-8588*Y^10*x^5+11397*Y^10*x^22+250771*Y^10*x^20+244963*Y^10*x^18-422587*Y^10*x^10-127968*Y^10*x^8+18952*Y^10*x^6+337294*Y^11*x^12+30*Y^11*x^2-2125*Y^11*x^4+159*Y^11*x^3+3*Y^11*x^29+676135*Y^11*x^13-587769*Y^11*x^17-297548*Y^11*x^16+1245696*Y^11*x^15-1468013*Y^11*x^14-678474*Y^11*x^11+11406*Y^11*x^24-7090*Y^11*x^25+1492*Y^11*x^26-53*Y^11*x^27-26*Y^11*x^28+16037*Y^11*x^23+85202*Y^11*x^21-681886*Y^11*x^19-108776*Y^11*x^9+27432*Y^11*x^7+8691*Y^11*x^5-89006*Y^11*x^22+197072*Y^11*x^20+929567*Y^11*x^18+415508*Y^11*x^10-11681*Y^11*x^8-19272*Y^11*x^6-132534*Y^12*x^12-10*Y^12*x^2-515*Y^12*x^4+210*Y^12*x^3+Y^12*x^30-18*Y^12*x^29+331197*Y^12*x^13-616544*Y^12*x^17-20318*Y^12*x^16+599506*Y^12*x^15-636185*Y^12*x^14+130775*Y^12*x^11+9937*Y^12*x^24-4606*Y^12*x^25+1915*Y^12*x^26-630*Y^12*x^27+140*Y^12*x^28-18081*Y^12*x^23-39390*Y^12*x^21-440772*Y^12*x^19+53666*Y^12*x^9-44086*Y^12*x^7-3102*Y^12*x^5+24162*Y^12*x^22+147510*Y^12*x^20+743401*Y^12*x^18-135197*Y^12*x^10+29488*Y^12*x^8+20081*Y^12*x^6+289609*Y^13*x^12+320*Y^13*x^4-28*Y^13*x^3+208267*Y^13*x^13-751668*Y^13*x^17+366351*Y^13*x^16+307281*Y^13*x^15-594851*Y^13*x^14-343510*Y^13*x^11+4585*Y^13*x^24-976*Y^13*x^25-73*Y^13*x^26+61*Y^13*x^27-7*Y^13*x^28-7161*Y^13*x^23-16706*Y^13*x^21-370557*Y^13*x^19+73823*Y^13*x^9+22705*Y^13*x^7-1592*Y^13*x^5+2578*Y^13*x^22+124281*Y^13*x^20+665693*Y^13*x^18+93863*Y^13*x^10-72028*Y^13*x^8-269*Y^13*x^6-217553*Y^14*x^12-500*Y^14*x^4+70*Y^14*x^3-3*Y^14*x^29+482441*Y^14*x^13-501574*Y^14*x^17+362634*Y^14*x^16+11393*Y^14*x^15-405160*Y^14*x^14-54343*Y^14*x^11+4460*Y^14*x^24-2565*Y^14*x^25+1098*Y^14*x^26-296*Y^14*x^27+45*Y^14*x^28-7254*Y^14*x^23-22937*Y^14*x^21-224175*Y^14*x^19-63623*Y^14*x^9-73*Y^14*x^7+1311*Y^14*x^5+11390*Y^14*x^22+78529*Y^14*x^20+413711*Y^14*x^18+119258*Y^14*x^10+15689*Y^14*x^8-1981*Y^14*x^6-124951*Y^15*x^12-72*Y^15*x^4+65*Y^15*x^3-Y^15*x^29+125664*Y^15*x^13-343425*Y^15*x^17+314743*Y^15*x^16-167870*Y^15*x^15-14624*Y^15*x^14+73891*Y^15*x^11+4041*Y^15*x^24-1768*Y^15*x^25+568*Y^15*x^26-122*Y^15*x^27+16*Y^15*x^28-8045*Y^15*x^23-35036*Y^15*x^21-147684*Y^15*x^19+18434*Y^15*x^9-7488*Y^15*x^7-1257*Y^15*x^5+16624*Y^15*x^22+72592*Y^15*x^20+259714*Y^15*x^18-38485*Y^15*x^10-660*Y^15*x^8+5135*Y^15*x^6+20064*Y^16*x^12+153*Y^16*x^4-17132*Y^16*x^13-166111*Y^16*x^17+185676*Y^16*x^16-144085*Y^16*x^15+65998*Y^16*x^14-30454*Y^16*x^11+955*Y^16*x^24-293*Y^16*x^25+52*Y^16*x^26-4*Y^16*x^27-2220*Y^16*x^23-14096*Y^16*x^21-68400*Y^16*x^19+12937*Y^16*x^9+6964*Y^16*x^7-830*Y^16*x^5+5213*Y^16*x^22+34325*Y^16*x^20+115896*Y^16*x^18+12613*Y^16*x^10-17272*Y^16*x^8+36*Y^16*x^6-11099*Y^17*x^12+54*Y^17*x^4+12528*Y^17*x^13-30126*Y^17*x^17+39023*Y^17*x^16-36003*Y^17*x^15+12351*Y^17*x^14-10885*Y^17*x^11+17*Y^17*x^24-2*Y^17*x^25-40*Y^17*x^23-891*Y^17*x^21-11679*Y^17*x^19-14356*Y^17*x^9+3220*Y^17*x^7+52*Y^17*x^5+85*Y^17*x^22+4453*Y^17*x^20+20579*Y^17*x^18+23216*Y^17*x^10+909*Y^17*x^8-1407*Y^17*x^6-14502*Y^18*x^12+8284*Y^18*x^13-2035*Y^18*x^17+3117*Y^18*x^16-4038*Y^18*x^15+491*Y^18*x^14+10883*Y^18*x^11+3*Y^18*x^24-25*Y^18*x^23-159*Y^18*x^21-808*Y^18*x^19-5022*Y^18*x^9-656*Y^18*x^7+80*Y^18*x^5+81*Y^18*x^22+331*Y^18*x^20+1477*Y^18*x^18-906*Y^18*x^10+3651*Y^18*x^8-252*Y^18*x^6-1505*Y^19*x^12-1476*Y^19*x^13-1991*Y^19*x^17+3239*Y^19*x^16-3912*Y^19*x^15+3413*Y^19*x^14+3812*Y^19*x^11+Y^19*x^24-11*Y^19*x^23-125*Y^19*x^21-368*Y^19*x^19+1007*Y^19*x^9-351*Y^19*x^7+50*Y^19*x^22+209*Y^19*x^20+900*Y^19*x^18-3363*Y^19*x^10+416*Y^19*x^8+45*Y^19*x^6+931*Y^20*x^12-1361*Y^20*x^13-612*Y^20*x^17+1222*Y^20*x^16-1629*Y^20*x^15+1612*Y^20*x^14-187*Y^20*x^11-31*Y^20*x^19+461*Y^20*x^9-9*Y^20*x^7+2*Y^20*x^20+188*Y^20*x^18-450*Y^20*x^10-147*Y^20*x^8+234*Y^21*x^12-213*Y^21*x^13-50*Y^21*x^17+124*Y^21*x^16-189*Y^21*x^15+206*Y^21*x^14-195*Y^21*x^11-Y^21*x^19+10*Y^21*x^9+11*Y^21*x^18+78*Y^21*x^10-20*Y^21*x^8+15*Y^22*x^12-6*Y^22*x^13+Y^22*x^14-20*Y^22*x^11-6*Y^22*x^9+15*Y^22*x^10+9*x^2*Y^3-6*x^2*Y^2+x^2*Y+x^8*Y^22+5*x^7*Y^21+10*x^6*Y^20+10*x^5*Y^19+5*x^4*Y^18+x^3*Y^17+15*x^3*Y^16+x^2*Y^15+7*x^2*Y^14+9*x^2*Y^13-x*Y^12-5*x*Y^11-5*x*Y^10-x*Y^9-13*x*Y^8-2*x^2*Y^6+7*x^2*Y^5-5110*Y*x^12+50*Y*x^4-11*Y*x^3+6439*Y*x^13+473*Y*x^17-1644*Y*x^16+3739*Y*x^15+3173*Y*x^11+6*Y*x^19+1391*Y*x^9+261*Y*x^7-111*Y*x^5-80*Y*x^18-1953*Y*x^10-848*Y*x^8+71*Y*x^6+20215*Y^2*x^12-426*Y^2*x^4+78*Y^2*x^3-32815*Y^2*x^13-11387*Y^2*x^17+23172*Y^2*x^16-36132*Y^2*x^15+40918*Y^2*x^14-14789*Y^2*x^11-Y^2*x^23-115*Y^2*x^21-1667*Y^2*x^19-14625*Y^2*x^9-1113*Y^2*x^7+1206*Y^2*x^5+16*Y^2*x^22+509*Y^2*x^20+4638*Y^2*x^18+15992*Y^2*x^10+7850*Y^2*x^8-1518*Y^2*x^6-47216*Y^3*x^12+1272*Y^3*x^4-171*Y^3*x^3-55*x^9-x^7+x^18+165*x^10+11*x^8-5847*Y*x^14-2*x^2*Y^4;

R4<Y,y>:=PolynomialRing(Rationals(),2);

PolyYy:=-11*Y^16*y^2+20*y^6-15*y^7+29*Y^11*y+5*Y^19*y^3-y^3+6*y^4-15*y^5+Y^14-y^9+5*Y^15*y+10*Y^18*y^3+9*Y^17*y^2+13*Y^13*y+6*y^8+18*Y^21*y^5+9*Y^20*y^4+55*Y^4*y^2-125*Y^5*y^2+2*Y^12*y-Y^6*y+7*Y^22*y^5+Y^23*y^5+8*Y^7*y-4*Y^23*y^8+Y^23*y^9-4*Y^23*y^6+6*Y^23*y^7-20*Y^8*y-67*Y^22*y^12+131*Y^22*y^11-130*Y^22*y^10+18*Y^22*y^13-2*Y^22*y^14+29*Y^22*y^8-14*Y^22*y^6-11*Y^22*y^7+39*Y^22*y^9+909*Y^21*y^12-1239*Y^21*y^11+688*Y^21*y^10+107*Y^21*y^13-729*Y^21*y^14+304*Y^21*y^8+639*Y^21*y^15-302*Y^21*y^16+86*Y^21*y^17-14*Y^21*y^18+Y^21*y^19+20*Y^21*y^6-212*Y^21*y^7-276*Y^21*y^9-3967*Y^20*y^12-4524*Y^20*y^11+7106*Y^20*y^10+9937*Y^20*y^13-8186*Y^20*y^14+1779*Y^20*y^8+3003*Y^20*y^15+142*Y^20*y^16-646*Y^20*y^17+290*Y^20*y^18-60*Y^20*y^19+5*Y^20*y^20+166*Y^20*y^6-697*Y^20*y^7-11*Y^20*y^5-4346*Y^20*y^9-57839*Y^19*y^12+25689*Y^19*y^11+8982*Y^19*y^10+51823*Y^19*y^13-18444*Y^19*y^14+7622*Y^19*y^8-5857*Y^19*y^15+8976*Y^19*y^16-3567*Y^19*y^17+249*Y^19*y^18+275*Y^19*y^19-95*Y^19*y^20+10*Y^19*y^21+20*Y^19*y^4+78*Y^19*y^5-16670*Y^19*y^9-415*Y^19*y^6-842*Y^19*y^7-191865*Y^18*y^12+199156*Y^18*y^11-95229*Y^18*y^10+61871*Y^18*y^13+54438*Y^18*y^14+10443*Y^18*y^8-66792*Y^18*y^15+22047*Y^18*y^16+7130*Y^18*y^17-8878*Y^18*y^18+3241*Y^18*y^19-561*Y^18*y^20+92*Y^18*y^21-41*Y^18*y^22-Y^18*y^24+11*Y^18*y^23-2485*Y^18*y^6-250*Y^18*y^7+98*Y^18*y^4+447*Y^18*y^5+7118*Y^18*y^9-17*Y^10*y-293885*Y^17*y^12+533520*Y^17*y^11-424289*Y^17*y^10-72701*Y^17*y^13+202882*Y^17*y^14-25794*Y^17*y^8-81538*Y^17*y^15-43834*Y^17*y^16+52245*Y^17*y^17-11563*Y^17*y^18-7497*Y^17*y^19+5171*Y^17*y^20-868*Y^17*y^21-187*Y^17*y^22-9*Y^17*y^24+87*Y^17*y^23-6169*Y^17*y^6+4760*Y^17*y^7-Y^17*y^3+64*Y^17*y^4+1770*Y^17*y^5+167827*Y^17*y^9-257952*Y^16*y^12+950395*Y^16*y^11-1012879*Y^16*y^10-372701*Y^16*y^13+388044*Y^16*y^14-160966*Y^16*y^8-55959*Y^16*y^15-119409*Y^16*y^16+64321*Y^16*y^17+18185*Y^16*y^18-30403*Y^16*y^19+11234*Y^16*y^20-415*Y^16*y^21-788*Y^16*y^22+184*Y^16*y^3+162*Y^16*y^4-319*Y^16*y^5+559321*Y^16*y^9-3*Y^16*y^25+4*Y^16*y^24+170*Y^16*y^23-2366*Y^16*y^6+22151*Y^16*y^7-16733*Y^15*y^20+16891*Y^15*y^21-9374*Y^15*y^22+166627*Y^15*y^12+1160594*Y^15*y^11-1466926*Y^15*y^10-1173228*Y^15*y^13+981956*Y^15*y^14-246294*Y^15*y^8-271072*Y^15*y^15-68856*Y^15*y^16+31466*Y^15*y^17+26212*Y^15*y^18-7024*Y^15*y^19+4*Y^15*y^27-62*Y^15*y^26+408*Y^15*y^25-1557*Y^15*y^24+4193*Y^15*y^23+2*Y^15*y^2-15553*Y^15*y^6+49810*Y^15*y^7-184*Y^15*y^3+1550*Y^15*y^4+1069*Y^15*y^5+836076*Y^15*y^9+2158706*Y^14*y^12+624035*Y^14*y^11-1993185*Y^14*y^10-3136781*Y^14*y^13+1241611*Y^14*y^14-271573*Y^14*y^8+904744*Y^14*y^15-1187539*Y^14*y^16+396513*Y^14*y^17+52412*Y^14*y^18-21664*Y^14*y^19-46157*Y^14*y^20+22556*Y^14*y^21+6099*Y^14*y^22+Y^14*y^29-16*Y^14*y^28+112*Y^14*y^27-411*Y^14*y^26+560*Y^14*y^25+1550*Y^14*y^24-7445*Y^14*y^23-7*Y^14*y+107*Y^14*y^2+22943*Y^14*y^6-49993*Y^14*y^7+144*Y^14*y^3-1614*Y^14*y^4+2247*Y^14*y^5+1282044*Y^14*y^9+2287288*Y^13*y^12-911514*Y^13*y^11-365709*Y^13*y^10-1556723*Y^13*y^13-993357*Y^13*y^14-204488*Y^13*y^8+2396477*Y^13*y^15-1388236*Y^13*y^16-143746*Y^13*y^17+498236*Y^13*y^18-90228*Y^13*y^19-128288*Y^13*y^20+42796*Y^13*y^21+47875*Y^13*y^22+3*Y^13*y^29-48*Y^13*y^28+303*Y^13*y^27-731*Y^13*y^26-1529*Y^13*y^25+15821*Y^13*y^24-45397*Y^13*y^23-41*Y^13*y^2+2037*Y^13*y^6+45990*Y^13*y^7-149*Y^13*y^3+4598*Y^13*y^4-12188*Y^13*y^5+500935*Y^13*y^9+2987243*Y^12*y^12+1075625*Y^12*y^11-2001069*Y^12*y^10-5588702*Y^12*y^13+3097534*Y^12*y^14+442438*Y^12*y^8+1253503*Y^12*y^15-2425036*Y^12*y^16+513162*Y^12*y^17+1128356*Y^12*y^18-1086678*Y^12*y^19+357848*Y^12*y^20+67267*Y^12*y^21-119308*Y^12*y^22-Y^12*y^28+37*Y^12*y^27-485*Y^12*y^26+3602*Y^12*y^25-17726*Y^12*y^24+59048*Y^12*y^23+218*Y^12*y^2+44798*Y^12*y^6-312905*Y^12*y^7-492*Y^12*y^3-3514*Y^12*y^4+13892*Y^12*y^5+511343*Y^12*y^9+17*Y^9*y+3159735*Y^11*y^12-2929114*Y^11*y^11+1233779*Y^11*y^10-931071*Y^11*y^13-2192727*Y^11*y^14-331952*Y^11*y^8+3239808*Y^11*y^15-1379059*Y^11*y^16-936354*Y^11*y^17+1343035*Y^11*y^18-305685*Y^11*y^19-466178*Y^11*y^20+433916*Y^11*y^21-131043*Y^11*y^22+18*Y^11*y^29-124*Y^11*y^28+287*Y^11*y^27+1221*Y^11*y^26-10952*Y^11*y^25+32259*Y^11*y^24-22710*Y^11*y^23-Y^11*y^30-309*Y^11*y^2+75664*Y^11*y^6+67158*Y^11*y^7+1493*Y^11*y^3+5668*Y^11*y^4-45676*Y^11*y^5+88885*Y^11*y^9+3849652*Y^10*y^11-1732228*Y^10*y^10-2509978*Y^10*y^13+4618010*Y^10*y^14+851043*Y^10*y^8-1487436*Y^10*y^15-3165390*Y^10*y^16+4580497*Y^10*y^17-2575837*Y^10*y^18+159600*Y^10*y^19+784798*Y^10*y^20-601244*Y^10*y^21+222257*Y^10*y^22-2143560*Y^10*y^12-9*Y^10*y^28+164*Y^10*y^27-1269*Y^10*y^26+5005*Y^10*y^25-6522*Y^10*y^24-34826*Y^10*y^23+397*Y^10*y^2-50706*Y^10*y^6-235191*Y^10*y^7-2413*Y^10*y^3+1249*Y^10*y^4+30445*Y^10*y^5-556491*Y^10*y^9+938443*Y^9*y^12-1543692*Y^9*y^11+137301*Y^9*y^10+1804400*Y^9*y^13-3600210*Y^9*y^14-667693*Y^9*y^8+1775758*Y^9*y^15+2348591*Y^9*y^16-4940399*Y^9*y^17+4183479*Y^9*y^18-1700697*Y^9*y^19-145107*Y^9*y^20+641278*Y^9*y^21-419461*Y^9*y^22-3*Y^9*y^29+57*Y^9*y^28-457*Y^9*y^27+1763*Y^9*y^26-830*Y^9*y^25-26521*Y^9*y^24+148089*Y^9*y^23-408*Y^9*y^2+141115*Y^9*y^6+29611*Y^9*y^7+3596*Y^9*y^3-4710*Y^9*y^4-45363*Y^9*y^5+942053*Y^9*y^9-3397754*Y^8*y^12+2714409*Y^8*y^11-315795*Y^8*y^10+431619*Y^8*y^13+3271769*Y^8*y^14+407264*Y^8*y^8-3118296*Y^8*y^15-855530*Y^8*y^16+4233025*Y^8*y^17-4178925*Y^8*y^18+1989687*Y^8*y^19-159100*Y^8*y^20-440161*Y^8*y^21+333208*Y^8*y^22-4106*Y^8*y^3+10826*Y^8*y^4+25699*Y^8*y^5-812164*Y^8*y^9+Y^8*y^29-19*Y^8*y^28+133*Y^8*y^27-189*Y^8*y^26-3514*Y^8*y^25+30581*Y^8*y^24-130635*Y^8*y^23+459*Y^8*y^2-148193*Y^8*y^6+115721*Y^8*y^7+1639376*Y^7*y^12-1259459*Y^7*y^11-96163*Y^7*y^10-87444*Y^7*y^13-1477107*Y^7*y^14-192961*Y^7*y^8+778406*Y^7*y^15+1484268*Y^7*y^16-2799718*Y^7*y^17+2219601*Y^7*y^18-873713*Y^7*y^19-8094*Y^7*y^20+224565*Y^7*y^21-145169*Y^7*y^22+6*Y^7*y^27-159*Y^7*y^26+1839*Y^7*y^25-12329*Y^7*y^24+52746*Y^7*y^23-311*Y^7*y^2+122601*Y^7*y^6-163492*Y^7*y^7+3618*Y^7*y^3-14231*Y^7*y^4-6959*Y^7*y^5+610274*Y^7*y^9+Y^2*y^2-498473*Y^6*y^12-161564*Y^6*y^11+632629*Y^6*y^10+713707*Y^6*y^13-638761*Y^6*y^14+5735*Y^6*y^8+770056*Y^6*y^15-1016764*Y^6*y^16+947275*Y^6*y^17-537355*Y^6*y^18+131606*Y^6*y^19+53520*Y^6*y^20-67518*Y^6*y^21+33107*Y^6*y^22+10*Y^6*y^26-203*Y^6*y^25+1848*Y^6*y^24-9845*Y^6*y^23+187*Y^6*y^2-88182*Y^6*y^6+176397*Y^6*y^7-2785*Y^6*y^3+12752*Y^6*y^4-2615*Y^6*y^5-454763*Y^6*y^9+2*y^14*Y-17*y^13*Y+65*y^12*Y-350*Y*y^9+245*Y*y^8-97*y^4*Y+15*y^3*Y-157*y^11*Y+277*y^10*Y+39*Y*y^7-259*Y*y^6+237*Y*y^5+456866*Y^5*y^12-25493*Y^5*y^11-182599*Y^5*y^10-698388*Y^5*y^13+614406*Y^5*y^14+153663*Y^5*y^8-404258*Y^5*y^15+236344*Y^5*y^16-121600*Y^5*y^17+39645*Y^5*y^18+4714*Y^5*y^19-14656*Y^5*y^20+9162*Y^5*y^21-3264*Y^5*y^22+39041*Y^5*y^9+5*Y^5*y^25-90*Y^5*y^24+715*Y^5*y^23+48671*Y^5*y^6-154457*Y^5*y^7+1833*Y^5*y^3-9825*Y^5*y^4+9690*Y^5*y^5-207654*Y^4*y^12+115944*Y^4*y^11-64104*Y^4*y^10+224292*Y^4*y^13-150161*Y^4*y^14-122439*Y^4*y^8+62040*Y^4*y^15-12897*Y^4*y^16-1764*Y^4*y^17+3124*Y^4*y^18-2109*Y^4*y^19+1115*Y^4*y^20-433*Y^4*y^21+110*Y^4*y^22+Y^4*y^24-16*Y^4*y^23-15558*Y^4*y^6+78749*Y^4*y^7-952*Y^4*y^3+5980*Y^4*y^4-9649*Y^4*y^5+96326*Y^4*y^9+38440*Y^3*y^12-36534*Y^3*y^11+35705*Y^3*y^10-29759*Y^3*y^13+14129*Y^3*y^14+38866*Y^3*y^8-2552*Y^3*y^15-1435*Y^3*y^16+1272*Y^3*y^17-460*Y^3*y^18+87*Y^3*y^19-7*Y^3*y^20+819*Y^3*y^6-20135*Y^3*y^7+368*Y^3*y^3-2510*Y^3*y^4+5099*Y^3*y^5-41381*Y^3*y^9-2873*Y^2*y^12+4155*Y^2*y^11-5464*Y^2*y^10+1486*Y^2*y^13-409*Y^2*y^14-5448*Y^2*y^8-60*Y^2*y^15+112*Y^2*y^16-50*Y^2*y^17+11*Y^2*y^18-Y^2*y^19+2054*Y^2*y^7-97*Y^2*y^3+661*Y^2*y^4-1518*Y^2*y^5+6464*Y^2*y^9-12*Y^3*y^2+976*Y^2*y^6;

return <PolyXx,PolyXy,PolyYx,PolyYy>;

end function;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function EquationsForX1()
//{equations for X_1(N) for N<=31 copyied from Sutherland's website}

R<x,y>:=PolynomialRing(Rationals(),2);

r:=(x^2*y-x*y+y-1)/(x*(x*y-1));
s:=(x*y-y+1)/(x*y);
b:=r*s*(r-1);//-1*(x-1)*(y-1)*x^(-3)*y^(-1)*(x*y-1)^(-2)*(x*y-y+1)*(x^2*y-x*y+y-1);
c:=s*(r-1);//-1*(x-1)*(y-1)*x^(-2)*y^(-1)*(x*y-1)^(-1)*(x*y-y+1);
//x:=(s-r)/(r*s-2*r+1);
//y:=(r*s-2*r+1)/(s^2-s-r+1);
f:=[];
f[2-1] := b/(16*b^2+(1-20*c-8*c^2)*b+c*(c-1)^3);
f[3-1] := b;
f[4-1] := c;
f[5-1] := b-c;
f[6-1] := s-1;
f[7-1] := s-r;
f[8-1] := r*s-2*r+1;
f[9-1] := s^2-s-r+1;
f[10-1] := x-y+1;
f[11-1] := x^2*y-x*y^2+y-1;
f[12-1] := x-y;
f[13-1] := x^3*y-x^2*y^2-x^2*y+x*y^2-y+1;
f[14-1] := x^2*y-x*y^2-x*y+y^2-1;
f[15-1] := x^2*y-x^2-x*y^2+x*y-x+y-1;
f[16-1] := x^2*y^2-2*x^2*y-x*y^3+2*x*y^2-y+1;
f[17-1] := x^4*y-x^3*y^3-x^3*y+x^2*y^4+x^2*y-x^2-x*y^4+x*y^3-x*y^2+x*y+y^3-2*y^2+y;
f[18-1] := x^4*y-3*x^3*y^2+x^3*y+2*x^2*y^3+x^2*y^2-2*x^2*y-2*x*y^3+2*x*y^2+y^2-2*y+1;
f[19-1] := x^5*y^2-3*x^4*y^3+3*x^3*y^4+2*x^3*y^2-2*x^3*y-x^2*y^5-x^2*y^4-x^2*y^3+x^2*y^2+x^2*y+x*y^5-x*y^4+2*x*y^3-2*x*y^2-x*y+x-y^4+2*y^3-y^2;
f[20-1] := x^4*y-2*x^3*y^2-x^3*y+x^2*y^3+x^2*y^2+2*x^2*y-x^2-2*x*y^2+x*y+y-1;
f[21-1] := x^5*y^2-3*x^4*y^3-x^4*y^2+3*x^3*y^4+3*x^3*y^3-x^2*y^5-3*x^2*y^4-2*x^2*y^2+3*x^2*y+x*y^5+3*x*y^3-4*x*y^2-y^4+y^3+y-1;
f[22-1] := x^5*y^2-x^5*y-2*x^4*y^3+2*x^4*y+x^3*y^4+3*x^3*y^3-4*x^3*y^2+x^3-2*x^2*y^4+x^2*y^3+x^2*y^2-x^2*y+x*y^4-x*y^3+x*y^2-x*y-y^3+2*y^2-y;
f[23-1]:=x^7*y^4 - 2*x^7*y^3 + x^7*y^2 - 3*x^6*y^5 + 4*x^6*y^4 + 3*x^5*y^6 - 5*x^5*y^4 - 
    3*x^5*y^3 + 3*x^5*y^2 - x^5*y - x^4*y^7 - 4*x^4*y^6 + 5*x^4*y^5 + 6*x^4*y^4 
    - x^4*y^3 - x^4*y^2 - x^4*y + 2*x^3*y^7 - 3*x^3*y^5 - 6*x^3*y^4 + 2*x^3*y^3 
    + 5*x^3*y^2 - x^3*y - x^2*y^7 + 3*x^2*y^5 + 2*x^2*y^4 - x^2*y^3 - 7*x^2*y^2 
    + 4*x^2*y + x*y^6 - 2*x*y^5 - 3*x*y^4 + 8*x*y^3 - 4*x*y^2 + y^3 - 3*y^2 + 
    3*y - 1;
f[24-1]:=x^5*y^4 - 3*x^5*y^3 + 3*x^5*y^2 - 2*x^4*y^5 + 5*x^4*y^4 - 5*x^4*y^3 + x^3*y^6 - 
    x^3*y^5 + x^3*y^4 - x^3*y^3 + 4*x^3*y^2 - 3*x^3*y - x^2*y^6 + x^2*y^5 - 
    x^2*y^4 + x^2*y^3 - x^2*y^2 + x^2*y + 2*x*y^5 - 5*x*y^4 + 5*x*y^3 - 2*x*y^2 
    - x*y + x - y^4 + 3*y^3 - 3*y^2 + y;
f[25-1]:=x^8*y^2 + x^7*y^5 - 4*x^7*y^4 - x^7*y^2 - 3*x^6*y^6 + 11*x^6*y^5 - 2*x^6*y^4 + 
    2*x^6*y^2 - 2*x^6*y + 3*x^5*y^7 - 9*x^5*y^6 - 4*x^5*y^5 + 4*x^5*y^4 - 
    2*x^5*y^3 + 4*x^5*y^2 - x^4*y^8 + x^4*y^7 + 9*x^4*y^6 - 5*x^4*y^5 + 
    6*x^4*y^4 - 15*x^4*y^3 + 7*x^4*y^2 - 2*x^4*y + x^4 + x^3*y^8 - 4*x^3*y^7 + 
    3*x^3*y^6 - 14*x^3*y^5 + 26*x^3*y^4 - 15*x^3*y^3 + 7*x^3*y^2 - 5*x^3*y + x^3
    - x^2*y^7 + 8*x^2*y^6 - 13*x^2*y^5 + 12*x^2*y^4 - 18*x^2*y^3 + 19*x^2*y^2 - 
    8*x^2*y + x^2 - 4*x*y^5 + 13*x*y^4 - 16*x*y^3 + 10*x*y^2 - 4*x*y + x + y^4 -
    4*y^3 + 6*y^2 - 4*y + 1;
f[26-1]:=x^6*y^2 - 5*x^5*y^3 + 2*x^5*y^2 + x^4*y^5 + 5*x^4*y^4 - 2*x^4*y^2 - x^4*y - 
    2*x^3*y^6 - 4*x^3*y^4 + 9*x^3*y^2 - 4*x^3*y + x^2*y^7 + 5*x^2*y^4 - 
    11*x^2*y^3 + 4*x^2*y^2 + x^2*y - x*y^7 + 2*x*y^6 - 4*x*y^5 + 6*x*y^4 - 
    3*x*y^3 + x*y^2 - 2*x*y + x + y^6 - 3*y^5 + 3*y^4 - y^3;
f[27-1]:=x^10*y^3 - 6*x^9*y^4 + 15*x^8*y^5 + 3*x^8*y^3 - 3*x^8*y^2 - 19*x^7*y^6 - 
    6*x^7*y^5 - 3*x^7*y^4 + 5*x^7*y^3 + 3*x^7*y^2 + 12*x^6*y^7 + 18*x^6*y^6 - 
    6*x^6*y^5 + 3*x^6*y^4 - 12*x^6*y^3 - 3*x^6*y^2 + 3*x^6*y - 3*x^5*y^8 - 
    18*x^5*y^7 + 6*x^5*y^6 - 12*x^5*y^5 + 27*x^5*y^4 - 3*x^5*y^3 - x^5*y^2 - 
    2*x^5*y + 6*x^4*y^8 + 3*x^4*y^7 + 10*x^4*y^6 - 24*x^4*y^5 + 3*x^4*y^4 - 
    2*x^4*y^3 + 5*x^4*y^2 + x^4*y - x^4 - 3*x^3*y^8 - 3*x^3*y^7 + 15*x^3*y^5 - 
    6*x^3*y^4 - 3*x^3*y^3 - x^3*y^2 + x^3*y + 6*x^2*y^7 - 12*x^2*y^6 + 
    10*x^2*y^5 - 13*x^2*y^4 + 15*x^2*y^3 - 7*x^2*y^2 + x^2*y - 4*x*y^6 + 
    13*x*y^5 - 16*x*y^4 + 10*x*y^3 - 4*x*y^2 + x*y + y^5 - 4*y^4 + 6*y^3 - 4*y^2
    + y;
f[28-1]:=x^8*y^2 - 5*x^7*y^3 + 10*x^6*y^4 + 2*x^6*y^2 - x^6*y - 10*x^5*y^5 - 10*x^5*y^3 +
    8*x^5*y^2 - x^5*y + 5*x^4*y^6 + x^4*y^5 + 13*x^4*y^4 - 9*x^4*y^3 - x^4*y^2 -
    x^4*y - x^3*y^7 - 2*x^3*y^6 - 4*x^3*y^5 - 4*x^3*y^4 + 8*x^3*y^3 + 2*x^3*y^2 
    - x^3*y + x^2*y^7 - x^2*y^6 + 8*x^2*y^5 - 11*x^2*y^4 + 8*x^2*y^3 - 
    10*x^2*y^2 + 5*x^2*y - 2*x*y^6 + 5*x*y^5 - 10*x*y^4 + 14*x*y^3 - 8*x*y^2 + 
    x*y + y^5 - 3*y^4 + 4*y^3 - 4*y^2 + 3*y - 1;
f[29-1]:=x^12*y^5 - x^12*y^4 - 6*x^11*y^6 + 4*x^11*y^5 + 2*x^11*y^4 + 15*x^10*y^7 - 
    3*x^10*y^6 - 10*x^10*y^5 - 3*x^10*y^4 + x^10*y^3 - 20*x^9*y^8 - 10*x^9*y^7 +
    18*x^9*y^6 + 14*x^9*y^5 + 4*x^9*y^4 - 7*x^9*y^3 + 15*x^8*y^9 + 25*x^8*y^8 - 
    10*x^8*y^7 - 27*x^8*y^6 - 23*x^8*y^5 + 18*x^8*y^4 + 6*x^8*y^3 - 6*x^7*y^10 -
    24*x^7*y^9 - 9*x^7*y^8 + 21*x^7*y^7 + 46*x^7*y^6 - 17*x^7*y^5 - 7*x^7*y^4 - 
    20*x^7*y^3 + 10*x^7*y^2 + x^6*y^11 + 11*x^6*y^10 + 15*x^6*y^9 + 4*x^6*y^8 - 
    51*x^6*y^7 + 8*x^6*y^6 - 15*x^6*y^5 + 54*x^6*y^4 - 18*x^6*y^3 - 5*x^6*y^2 - 
    2*x^5*y^11 - 7*x^5*y^10 - 15*x^5*y^9 + 26*x^5*y^8 + 39*x^5*y^6 - 63*x^5*y^5 
    + 14*x^5*y^4 + 12*x^5*y^2 - 5*x^5*y + x^4*y^11 + 6*x^4*y^10 + x^4*y^9 - 
    4*x^4*y^8 - 29*x^4*y^7 + 26*x^4*y^6 + 6*x^4*y^5 + x^4*y^4 - 12*x^4*y^3 + 
    2*x^4*y^2 + 2*x^4*y - 4*x^3*y^10 + 2*x^3*y^9 + 21*x^3*y^7 - 33*x^3*y^6 + 
    20*x^3*y^5 - 13*x^3*y^4 + 11*x^3*y^3 - 3*x^3*y^2 - 2*x^3*y + x^3 + 6*x^2*y^9
    - 18*x^2*y^8 + 25*x^2*y^7 - 33*x^2*y^6 + 42*x^2*y^5 - 34*x^2*y^4 + 
    15*x^2*y^3 - 3*x^2*y^2 - 4*x*y^8 + 17*x*y^7 - 30*x*y^6 + 30*x*y^5 - 20*x*y^4
    + 9*x*y^3 - 2*x*y^2 + y^7 - 5*y^6 + 10*y^5 - 10*y^4 + 5*y^3 - y^2;
f[30-1]:=x^8*y^4 - x^8*y^3 - 4*x^7*y^5 + x^7*y^4 + 4*x^7*y^3 + 6*x^6*y^6 + 5*x^6*y^5 - 
    11*x^6*y^4 - 7*x^6*y^3 + 3*x^6*y^2 - 4*x^5*y^7 - 11*x^5*y^6 + 9*x^5*y^5 + 
    15*x^5*y^4 + 6*x^5*y^3 - 9*x^5*y^2 + x^4*y^8 + 8*x^4*y^7 - 9*x^4*y^5 - 
    20*x^4*y^4 + 6*x^4*y^3 + 13*x^4*y^2 - 3*x^4*y - 2*x^3*y^8 - 3*x^3*y^7 + 
    x^3*y^6 + 9*x^3*y^5 + 15*x^3*y^4 - 17*x^3*y^3 - 8*x^3*y^2 + 6*x^3*y + 
    x^2*y^8 + 3*x^2*y^6 - 14*x^2*y^5 + 5*x^2*y^4 + 6*x^2*y^3 + 5*x^2*y^2 - 
    7*x^2*y + x^2 - x*y^7 + 2*x*y^6 - x*y^5 + 5*x*y^4 - 10*x*y^3 + 4*x*y^2 + 
    2*x*y - x - y^3 + 3*y^2 - 3*y + 1;
f[31-1]:=x^13*y^7 - 3*x^13*y^6 + 3*x^13*y^5 - x^13*y^4 - 6*x^12*y^8 + 15*x^12*y^7 - 
    10*x^12*y^6 + 15*x^11*y^9 - 27*x^11*y^8 + 12*x^11*y^6 + 12*x^11*y^5 - 
    8*x^11*y^4 + 2*x^11*y^3 - 20*x^10*y^10 + 15*x^10*y^9 + 42*x^10*y^8 - 
    23*x^10*y^7 - 45*x^10*y^6 + 12*x^10*y^5 + 2*x^10*y^4 + 2*x^10*y^3 + 
    15*x^9*y^11 + 15*x^9*y^10 - 70*x^9*y^9 + 6*x^9*y^8 + 49*x^9*y^7 + 42*x^9*y^6
    - 15*x^9*y^5 - 28*x^9*y^4 + 7*x^9*y^3 - x^9*y^2 - 6*x^8*y^12 - 27*x^8*y^11 +
    42*x^8*y^10 + 21*x^8*y^9 + 9*x^8*y^8 - 111*x^8*y^7 - 3*x^8*y^6 + 51*x^8*y^5 
    + 24*x^8*y^4 - 13*x^8*y^3 - 2*x^8*y^2 + x^7*y^13 + 15*x^7*y^12 - 20*x^7*y^10
    - 45*x^7*y^9 + 60*x^7*y^8 + 71*x^7*y^7 - 16*x^7*y^6 - 96*x^7*y^5 + 
    13*x^7*y^4 + 26*x^7*y^3 - 3*x^7*y^2 - 3*x^6*y^13 - 10*x^6*y^12 + 3*x^6*y^11 
    + 14*x^6*y^10 + 50*x^6*y^9 - 111*x^6*y^8 + 3*x^6*y^7 + 47*x^6*y^6 + 
    47*x^6*y^5 - 14*x^6*y^4 - 44*x^6*y^3 + 17*x^6*y^2 + 3*x^5*y^13 + 3*x^5*y^12 
    + 12*x^5*y^11 - 58*x^5*y^10 + 64*x^5*y^9 - 42*x^5*y^8 + 87*x^5*y^7 - 
    97*x^5*y^6 - 32*x^5*y^5 + 87*x^5*y^4 - 22*x^5*y^3 - 5*x^5*y^2 - x^4*y^13 - 
    6*x^4*y^12 + 9*x^4*y^11 - 4*x^4*y^10 + 32*x^4*y^9 - 69*x^4*y^8 + 34*x^4*y^7 
    + 43*x^4*y^6 - 51*x^4*y^5 + 23*x^4*y^4 - 30*x^4*y^3 + 27*x^4*y^2 - 7*x^4*y +
    4*x^3*y^12 - 6*x^3*y^11 + 4*x^3*y^10 - 24*x^3*y^9 + 59*x^3*y^8 - 70*x^3*y^7 
    + 60*x^3*y^6 - 59*x^3*y^5 + 59*x^3*y^4 - 34*x^3*y^3 + 6*x^3*y^2 + x^3*y - 
    6*x^2*y^11 + 24*x^2*y^10 - 46*x^2*y^9 + 70*x^2*y^8 - 96*x^2*y^7 + 
    100*x^2*y^6 - 70*x^2*y^5 + 31*x^2*y^4 - 10*x^2*y^3 + 6*x^2*y^2 - 4*x^2*y + 
    x^2 + 4*x*y^10 - 21*x*y^9 + 48*x*y^8 - 65*x*y^7 + 60*x*y^6 - 39*x*y^5 + 
    16*x*y^4 - 3*x*y^3 - y^9 + 6*y^8 - 15*y^7 + 20*y^6 - 15*y^5 + 6*y^4 - y^3;
f[37-1]:=x^19*y^8 - 2*x^19*y^7 + x^19*y^6 - 10*x^18*y^9 + 17*x^18*y^8 - 4*x^18*y^7 - 
    3*x^18*y^6 + 45*x^17*y^10 - 60*x^17*y^9 - 10*x^17*y^8 + 18*x^17*y^7 + 
    9*x^17*y^6 - 2*x^17*y^5 - 120*x^16*y^11 + 105*x^16*y^10 + 100*x^16*y^9 - 
    24*x^16*y^8 - 61*x^16*y^7 - 13*x^16*y^6 + 14*x^16*y^5 + 210*x^15*y^12 - 
    60*x^15*y^11 - 285*x^15*y^10 - 100*x^15*y^9 + 171*x^15*y^8 + 129*x^15*y^7 - 
    48*x^15*y^6 - 26*x^15*y^5 + x^15*y^4 - 252*x^14*y^13 - 127*x^14*y^12 + 
    419*x^14*y^11 + 440*x^14*y^10 - 130*x^14*y^9 - 484*x^14*y^8 + 38*x^14*y^7 + 
    71*x^14*y^6 + 84*x^14*y^5 - 31*x^14*y^4 + 210*x^13*y^14 + 342*x^13*y^13 - 
    317*x^13*y^12 - 715*x^13*y^11 - 475*x^13*y^10 + 1010*x^13*y^9 + 156*x^13*y^8
    + 27*x^13*y^7 - 392*x^13*y^6 + 53*x^13*y^5 + 45*x^13*y^4 - 120*x^12*y^15 - 
    405*x^12*y^14 + 39*x^12*y^13 + 520*x^12*y^12 + 1427*x^12*y^11 - 
    1036*x^12*y^10 - 575*x^12*y^9 - 569*x^12*y^8 + 877*x^12*y^7 + 50*x^12*y^6 - 
    46*x^12*y^5 - 127*x^12*y^4 + 35*x^12*y^3 + 45*x^11*y^16 + 290*x^11*y^15 + 
    170*x^11*y^14 - 37*x^11*y^13 - 1632*x^11*y^12 - x^11*y^11 + 837*x^11*y^10 + 
    1462*x^11*y^9 - 930*x^11*y^8 - 422*x^11*y^7 - 186*x^11*y^6 + 411*x^11*y^5 - 
    21*x^11*y^4 - 42*x^11*y^3 - 10*x^10*y^17 - 130*x^10*y^16 - 195*x^10*y^15 - 
    205*x^10*y^14 + 773*x^10*y^13 + 1202*x^10*y^12 - 541*x^10*y^11 - 
    1508*x^10*y^10 - 470*x^10*y^9 + 1085*x^10*y^8 + 634*x^10*y^7 - 561*x^10*y^6 
    - 140*x^10*y^5 + 31*x^10*y^4 + 84*x^10*y^3 - 21*x^10*y^2 + x^9*y^18 + 
    34*x^9*y^17 + 115*x^9*y^16 + 145*x^9*y^15 + 65*x^9*y^14 - 1261*x^9*y^13 + 
    31*x^9*y^12 + 130*x^9*y^11 + 2377*x^9*y^10 - 1173*x^9*y^9 - 819*x^9*y^8 - 
    189*x^9*y^7 + 695*x^9*y^6 - 25*x^9*y^5 - 145*x^9*y^4 - 10*x^9*y^3 + 
    21*x^9*y^2 - 4*x^8*y^18 - 39*x^8*y^17 - 52*x^8*y^16 - 210*x^8*y^15 + 
    505*x^8*y^14 + 189*x^8*y^13 + 883*x^8*y^12 - 2109*x^8*y^11 + 88*x^8*y^10 + 
    46*x^8*y^9 + 1928*x^8*y^8 - 1433*x^8*y^7 + 190*x^8*y^6 - 105*x^8*y^5 + 
    175*x^8*y^4 - 32*x^8*y^3 - 26*x^8*y^2 + 7*x^8*y + 6*x^7*y^18 + 17*x^7*y^17 +
    69*x^7*y^16 - 12*x^7*y^15 - 165*x^7*y^14 - 476*x^7*y^13 + 193*x^7*y^12 + 
    890*x^7*y^11 + 700*x^7*y^10 - 2097*x^7*y^9 + 946*x^7*y^8 - 601*x^7*y^7 + 
    1090*x^7*y^6 - 728*x^7*y^5 + 165*x^7*y^4 + 5*x^7*y^3 + 2*x^7*y^2 - 4*x^7*y -
    4*x^6*y^18 - 7*x^6*y^17 - 46*x^6*y^16 + 79*x^6*y^15 - 57*x^6*y^14 + 
    600*x^6*y^13 - 768*x^6*y^12 - 174*x^6*y^11 + 18*x^6*y^10 + 407*x^6*y^9 + 
    943*x^6*y^8 - 1700*x^6*y^7 + 868*x^6*y^6 - 212*x^6*y^5 + 85*x^6*y^4 - 
    40*x^6*y^3 + 6*x^6*y^2 + 3*x^6*y - x^6 + x^5*y^18 + 9*x^5*y^17 - 11*x^5*y^16
    + 59*x^5*y^15 - 231*x^5*y^14 + 230*x^5*y^13 - 324*x^5*y^12 + 904*x^5*y^11 - 
    660*x^5*y^10 - 339*x^5*y^9 + 210*x^5*y^8 + 336*x^5*y^7 - 73*x^5*y^6 - 
    209*x^5*y^5 + 119*x^5*y^4 - 23*x^5*y^3 + x^5*y^2 + x^5*y - 4*x^4*y^17 + 
    4*x^4*y^16 - 6*x^4*y^15 + 24*x^4*y^14 + 64*x^4*y^13 - 174*x^4*y^12 + 
    78*x^4*y^11 - 320*x^4*y^10 + 1040*x^4*y^9 - 1154*x^4*y^8 + 658*x^4*y^7 - 
    453*x^4*y^6 + 401*x^4*y^5 - 194*x^4*y^4 + 40*x^4*y^3 - 5*x^4*y^2 + x^4*y + 
    6*x^3*y^16 - 26*x^3*y^15 + 64*x^3*y^14 - 137*x^3*y^13 + 159*x^3*y^12 + 
    48*x^3*y^11 - 366*x^3*y^10 + 621*x^3*y^9 - 997*x^3*y^8 + 1322*x^3*y^7 - 
    1095*x^3*y^6 + 527*x^3*y^5 - 160*x^3*y^4 + 44*x^3*y^3 - 11*x^3*y^2 + x^3*y -
    4*x^2*y^15 + 24*x^2*y^14 - 67*x^2*y^13 + 122*x^2*y^12 - 129*x^2*y^11 - 
    52*x^2*y^10 + 444*x^2*y^9 - 767*x^2*y^8 + 795*x^2*y^7 - 647*x^2*y^6 + 
    466*x^2*y^5 - 263*x^2*y^4 + 94*x^2*y^3 - 17*x^2*y^2 + x^2*y + x*y^14 - 
    7*x*y^13 + 21*x*y^12 - 35*x*y^11 + 26*x*y^10 + 43*x*y^9 - 190*x*y^8 + 
    342*x*y^7 - 371*x*y^6 + 259*x*y^5 - 119*x*y^4 + 37*x*y^3 - 8*x*y^2 + x*y + 
    y^9 - 8*y^8 + 28*y^7 - 56*y^6 + 70*y^5 - 56*y^4 + 28*y^3 - 8*y^2 + y;
    
f[41-1]:=x^23*y^7 + x^22*y^12 - 6*x^22*y^11 + 15*x^22*y^10 - 20*x^22*y^9 - 3*x^22*y^7 - 
    10*x^21*y^13 + 55*x^21*y^12 - 123*x^21*y^11 + 143*x^21*y^10 + 10*x^21*y^9 + 
    8*x^21*y^7 - 5*x^21*y^6 + 45*x^20*y^14 - 220*x^20*y^13 + 415*x^20*y^12 - 
    384*x^20*y^11 - 204*x^20*y^10 + 13*x^20*y^9 + 30*x^20*y^8 + 9*x^20*y^7 + 
    10*x^20*y^6 - 120*x^19*y^15 + 495*x^19*y^14 - 685*x^19*y^13 + 355*x^19*y^12 
    + 901*x^19*y^11 + 210*x^19*y^10 - 284*x^19*y^9 - 167*x^19*y^8 + 25*x^19*y^7 
    - 25*x^19*y^6 + 10*x^19*y^5 + 210*x^18*y^16 - 660*x^18*y^15 + 360*x^18*y^14 
    + 400*x^18*y^13 - 1887*x^18*y^12 - 1090*x^18*y^11 + 274*x^18*y^10 + 
    1299*x^18*y^9 - 130*x^18*y^8 - 8*x^18*y^7 - 45*x^18*y^6 - 10*x^18*y^5 - 
    252*x^17*y^17 + 462*x^17*y^16 + 690*x^17*y^15 - 1260*x^17*y^14 + 
    2140*x^17*y^13 + 2066*x^17*y^12 + 1608*x^17*y^11 - 3833*x^17*y^10 - 
    518*x^17*y^9 + 72*x^17*y^8 + 617*x^17*y^7 - 96*x^17*y^6 + 30*x^17*y^5 - 
    10*x^17*y^4 + 210*x^16*y^18 - 1554*x^16*y^16 + 864*x^16*y^15 - 
    1335*x^16*y^14 - 1620*x^16*y^13 - 5026*x^16*y^12 + 5108*x^16*y^11 + 
    2854*x^16*y^10 + 1494*x^16*y^9 - 2876*x^16*y^8 + 34*x^16*y^7 + 50*x^16*y^6 +
    81*x^16*y^5 - 120*x^15*y^19 - 330*x^15*y^18 + 1350*x^15*y^17 + 678*x^15*y^16
    + 723*x^15*y^15 + 84*x^15*y^14 + 5650*x^15*y^13 - 2108*x^15*y^12 - 
    4637*x^15*y^11 - 6325*x^15*y^10 + 4970*x^15*y^9 + 1985*x^15*y^8 + 
    246*x^15*y^7 - 1023*x^15*y^6 + 159*x^15*y^5 - 20*x^15*y^4 + 5*x^15*y^3 + 
    45*x^14*y^20 + 330*x^14*y^19 - 465*x^14*y^18 - 1620*x^14*y^17 - 
    1102*x^14*y^16 + 105*x^14*y^15 - 1647*x^14*y^14 - 1806*x^14*y^13 + 
    2730*x^14*y^12 + 9615*x^14*y^11 - 939*x^14*y^10 - 6205*x^14*y^9 - 
    2820*x^14*y^8 + 2859*x^14*y^7 + 425*x^14*y^6 - 159*x^14*y^5 - 66*x^14*y^4 + 
    5*x^14*y^3 - 10*x^13*y^21 - 165*x^13*y^20 - 135*x^13*y^19 + 1175*x^13*y^18 +
    1506*x^13*y^17 + 1379*x^13*y^16 - 1829*x^13*y^15 + 1176*x^13*y^14 - 
    146*x^13*y^13 - 4479*x^13*y^12 - 8463*x^13*y^11 + 8466*x^13*y^10 + 
    5371*x^13*y^9 - 319*x^13*y^8 - 3794*x^13*y^7 - 230*x^13*y^6 + 908*x^13*y^5 -
    134*x^13*y^4 + 10*x^13*y^3 - x^13*y^2 + x^12*y^22 + 44*x^12*y^21 + 
    195*x^12*y^20 - 320*x^12*y^19 - 1090*x^12*y^18 - 2157*x^12*y^17 + 
    935*x^12*y^16 + 1783*x^12*y^15 + 1548*x^12*y^14 - 3917*x^12*y^13 + 
    12434*x^12*y^12 - 7683*x^12*y^11 + 3*x^12*y^10 - 10042*x^12*y^9 + 
    7873*x^12*y^8 + 2083*x^12*y^7 - 1256*x^12*y^6 - 725*x^12*y^5 + 190*x^12*y^4 
    + 25*x^12*y^3 - 2*x^12*y^2 - 5*x^11*y^22 - 73*x^11*y^21 - 57*x^11*y^20 + 
    375*x^11*y^19 + 1355*x^11*y^18 + 1203*x^11*y^17 - 1902*x^11*y^16 - 
    3961*x^11*y^15 + 4746*x^11*y^14 - 7589*x^11*y^13 + 8104*x^11*y^12 - 
    10131*x^11*y^11 + 16906*x^11*y^10 - 7130*x^11*y^9 - 1905*x^11*y^8 - 
    2805*x^11*y^7 + 3155*x^11*y^6 + 135*x^11*y^5 - 455*x^11*y^4 + 50*x^11*y^3 - 
    3*x^11*y^2 + 10*x^10*y^22 + 56*x^10*y^21 - 19*x^10*y^20 - 352*x^10*y^19 - 
    1335*x^10*y^18 + 59*x^10*y^17 + 2922*x^10*y^16 + 31*x^10*y^15 + 
    2603*x^10*y^14 - 7955*x^10*y^13 + 9137*x^10*y^12 - 8423*x^10*y^11 + 
    1039*x^10*y^10 - 573*x^10*y^9 + 6595*x^10*y^8 - 3124*x^10*y^7 - 
    1079*x^10*y^6 - 94*x^10*y^5 + 640*x^10*y^4 - 135*x^10*y^3 - 4*x^10*y^2 - 
    10*x^9*y^22 - 24*x^9*y^21 - 5*x^9*y^20 + 441*x^9*y^19 + 638*x^9*y^18 - 
    500*x^9*y^17 - 1875*x^9*y^16 - 1516*x^9*y^15 + 2911*x^9*y^14 + 2718*x^9*y^13
    - 5723*x^9*y^12 + 6944*x^9*y^11 - 4648*x^9*y^10 + 1439*x^9*y^9 - 
    3058*x^9*y^8 + 1604*x^9*y^7 + 2091*x^9*y^6 - 1538*x^9*y^5 - 14*x^9*y^4 + 
    130*x^9*y^3 - 5*x^9*y^2 + 5*x^8*y^22 + 16*x^8*y^21 - 15*x^8*y^20 - 
    280*x^8*y^19 - 304*x^8*y^18 + 567*x^8*y^17 + 1058*x^8*y^16 + 2029*x^8*y^15 -
    8016*x^8*y^14 + 9710*x^8*y^13 - 12848*x^8*y^12 + 16752*x^8*y^11 - 
    15945*x^8*y^10 + 11762*x^8*y^9 - 4722*x^8*y^8 - 297*x^8*y^7 + 258*x^8*y^6 + 
    162*x^8*y^5 + 367*x^8*y^4 - 319*x^8*y^3 + 60*x^8*y^2 - x^7*y^22 - 
    13*x^7*y^21 + 25*x^7*y^20 + 105*x^7*y^19 + 180*x^7*y^18 - 211*x^7*y^17 - 
    1971*x^7*y^16 + 3627*x^7*y^15 - 4958*x^7*y^14 + 11322*x^7*y^13 - 
    17498*x^7*y^12 + 17311*x^7*y^11 - 14209*x^7*y^10 + 9998*x^7*y^9 - 
    5677*x^7*y^8 + 2696*x^7*y^7 - 265*x^7*y^6 - 936*x^7*y^5 + 537*x^7*y^4 - 
    43*x^7*y^3 - 19*x^7*y^2 + 4*x^6*y^21 + 2*x^6*y^20 - 70*x^6*y^19 - 
    75*x^6*y^18 + 322*x^6*y^17 + 21*x^6*y^16 + 868*x^6*y^15 - 3910*x^6*y^14 + 
    5210*x^6*y^13 - 4945*x^6*y^12 + 6395*x^6*y^11 - 6995*x^6*y^10 + 4855*x^6*y^9
    - 2228*x^6*y^8 + 315*x^6*y^7 + 507*x^6*y^6 - 375*x^6*y^5 + 190*x^6*y^4 - 
    152*x^6*y^3 + 73*x^6*y^2 - 12*x^6*y - 6*x^5*y^20 + 22*x^5*y^19 + 65*x^5*y^18
    - 213*x^5*y^17 + 136*x^5*y^16 - 628*x^5*y^15 + 2358*x^5*y^14 - 3465*x^5*y^13
    + 3459*x^5*y^12 - 4401*x^5*y^11 + 5397*x^5*y^10 - 4475*x^5*y^9 + 
    2796*x^5*y^8 - 1672*x^5*y^7 + 958*x^5*y^6 - 513*x^5*y^5 + 255*x^5*y^4 - 
    81*x^5*y^3 + 6*x^5*y^2 + 2*x^5*y + 4*x^4*y^19 - 23*x^4*y^18 - 61*x^4*y^17 + 
    541*x^4*y^16 - 1433*x^4*y^15 + 2777*x^4*y^14 - 5327*x^4*y^13 + 8741*x^4*y^12
    - 10719*x^4*y^11 + 10274*x^4*y^10 - 8543*x^4*y^9 + 6220*x^4*y^8 - 
    3625*x^4*y^7 + 1589*x^4*y^6 - 527*x^4*y^5 + 137*x^4*y^4 - 35*x^4*y^3 + 
    15*x^4*y^2 - 6*x^4*y + x^4 - x^3*y^18 + 7*x^3*y^17 + 63*x^3*y^16 - 
    553*x^3*y^15 + 1837*x^3*y^14 - 3778*x^3*y^13 + 5974*x^3*y^12 - 8100*x^3*y^11
    + 9285*x^3*y^10 - 8477*x^3*y^9 + 5999*x^3*y^8 - 3321*x^3*y^7 + 1447*x^3*y^6 
    - 472*x^3*y^5 + 100*x^3*y^4 - 10*x^3*y^3 - 36*x^2*y^15 + 297*x^2*y^14 - 
    1108*x^2*y^13 + 2508*x^2*y^12 - 3942*x^2*y^11 + 4710*x^2*y^10 - 4536*x^2*y^9
    + 3564*x^2*y^8 - 2208*x^2*y^7 + 1017*x^2*y^6 - 324*x^2*y^5 + 64*x^2*y^4 - 
    6*x^2*y^3 + 9*x*y^14 - 83*x*y^13 + 345*x*y^12 - 855*x*y^11 + 1410*x*y^10 - 
    1638*x*y^9 + 1386*x*y^8 - 870*x*y^7 + 405*x*y^6 - 135*x*y^5 + 29*x*y^4 - 
    3*x*y^3 - y^13 + 10*y^12 - 45*y^11 + 120*y^10 - 210*y^9 + 252*y^8 - 210*y^7 
    + 120*y^6 - 45*y^5 + 10*y^4 - y^3;
f[43-1]:=x^26*y^9 - x^26*y^8 - 15*x^25*y^10 + 14*x^25*y^9 + x^25*y^8 + 105*x^24*y^11 - 
    90*x^24*y^10 - 8*x^24*y^9 - 14*x^24*y^8 + 7*x^24*y^7 + x^23*y^14 - 
    9*x^23*y^13 - 419*x^23*y^12 + 266*x^23*y^11 + 126*x^23*y^10 + 90*x^23*y^9 - 
    40*x^23*y^8 - 15*x^23*y^7 - 10*x^22*y^15 + 85*x^22*y^14 + 1044*x^22*y^13 - 
    196*x^22*y^12 - 776*x^22*y^11 - 441*x^22*y^10 + 175*x^22*y^9 + 77*x^22*y^8 +
    63*x^22*y^7 - 21*x^22*y^6 + 45*x^21*y^16 - 355*x^21*y^15 - 1762*x^21*y^14 - 
    970*x^21*y^13 + 2140*x^21*y^12 + 1975*x^21*y^11 - 290*x^21*y^10 - 
    595*x^21*y^9 - 266*x^21*y^8 + 28*x^21*y^7 + 49*x^21*y^6 - 120*x^20*y^17 + 
    855*x^20*y^16 + 2330*x^20*y^15 + 3267*x^20*y^14 - 2524*x^20*y^13 - 
    5978*x^20*y^12 - 1390*x^20*y^11 + 2820*x^20*y^10 + 988*x^20*y^9 + 
    77*x^20*y^8 - 224*x^20*y^7 - 126*x^20*y^6 + 35*x^20*y^5 + 210*x^19*y^18 - 
    1290*x^19*y^17 - 3060*x^19*y^16 - 4850*x^19*y^15 - 684*x^19*y^14 + 
    11096*x^19*y^13 + 8126*x^19*y^12 - 5618*x^19*y^11 - 4470*x^19*y^10 - 
    1260*x^19*y^9 + 1412*x^19*y^8 + 406*x^19*y^7 + 7*x^19*y^6 - 70*x^19*y^5 - 
    252*x^18*y^19 + 1218*x^18*y^18 + 4233*x^18*y^17 + 4413*x^18*y^16 + 
    6178*x^18*y^15 - 12206*x^18*y^14 - 18638*x^18*y^13 + 1752*x^18*y^12 + 
    11620*x^18*y^11 + 8332*x^18*y^10 - 4833*x^18*y^9 - 1821*x^18*y^8 - 
    261*x^18*y^7 + 287*x^18*y^6 + 133*x^18*y^5 - 35*x^18*y^4 + 210*x^17*y^20 - 
    630*x^17*y^19 - 4963*x^17*y^18 - 3638*x^17*y^17 - 8718*x^17*y^16 + 
    6667*x^17*y^15 + 24875*x^17*y^14 + 11509*x^17*y^13 - 12830*x^17*y^12 - 
    25067*x^17*y^11 + 3669*x^17*y^10 + 8242*x^17*y^9 + 2544*x^17*y^8 - 
    1719*x^17*y^7 - 424*x^17*y^6 + 14*x^17*y^5 + 49*x^17*y^4 - 120*x^16*y^21 + 
    30*x^16*y^20 + 4101*x^16*y^19 + 4228*x^16*y^18 + 6680*x^16*y^17 + 
    1065*x^16*y^16 - 22845*x^16*y^15 - 20839*x^16*y^14 - 2906*x^16*y^13 + 
    39108*x^16*y^12 + 14454*x^16*y^11 - 15513*x^16*y^10 - 12860*x^16*y^9 + 
    2714*x^16*y^8 + 3369*x^16*y^7 - 194*x^16*y^6 - 164*x^16*y^5 - 77*x^16*y^4 + 
    21*x^16*y^3 + 45*x^15*y^22 + 195*x^15*y^21 - 2115*x^15*y^20 - 4746*x^15*y^19
    - 3970*x^15*y^18 - 5494*x^15*y^17 + 17480*x^15*y^16 + 15935*x^15*y^15 + 
    23523*x^15*y^14 - 31710*x^15*y^13 - 38105*x^15*y^12 + 4316*x^15*y^11 + 
    27152*x^15*y^10 + 10144*x^15*y^9 - 12630*x^15*y^8 - 1599*x^15*y^7 + 
    1080*x^15*y^6 + 357*x^15*y^5 - 54*x^15*y^4 - 14*x^15*y^3 - 10*x^14*y^23 - 
    135*x^14*y^22 + 530*x^14*y^21 + 3490*x^14*y^20 + 3012*x^14*y^19 + 
    6075*x^14*y^18 - 11813*x^14*y^17 - 8034*x^14*y^16 - 26235*x^14*y^15 + 
    8962*x^14*y^14 + 38670*x^14*y^13 + 23070*x^14*y^12 - 20667*x^14*y^11 - 
    40151*x^14*y^10 + 15841*x^14*y^9 + 8672*x^14*y^8 + 2516*x^14*y^7 - 
    4388*x^14*y^6 + 696*x^14*y^5 + 2*x^14*y^4 + 24*x^14*y^3 - 7*x^14*y^2 + 
    x^13*y^24 + 41*x^13*y^23 + 36*x^13*y^22 - 1454*x^13*y^21 - 2404*x^13*y^20 - 
    4683*x^13*y^19 + 4736*x^13*y^18 + 7651*x^13*y^17 + 13335*x^13*y^16 + 
    7796*x^13*y^15 - 22718*x^13*y^14 - 28419*x^13*y^13 - 13064*x^13*y^12 + 
    55378*x^13*y^11 + 973*x^13*y^10 - 6941*x^13*y^9 - 22488*x^13*y^8 + 
    12293*x^13*y^7 + 420*x^13*y^6 - 359*x^13*y^5 - 214*x^13*y^4 + 40*x^13*y^3 - 
    x^13*y^2 - 5*x^12*y^24 - 56*x^12*y^23 + 259*x^12*y^22 + 1244*x^12*y^21 + 
    2624*x^12*y^20 + 1100*x^12*y^19 - 7935*x^12*y^18 - 3460*x^12*y^17 - 
    13504*x^12*y^16 + 17166*x^12*y^15 + 3761*x^12*y^14 + 40508*x^12*y^13 - 
    41397*x^12*y^12 - 10021*x^12*y^11 - 20668*x^12*y^10 + 43839*x^12*y^9 - 
    8137*x^12*y^8 - 3982*x^12*y^7 - 3954*x^12*y^6 + 3124*x^12*y^5 - 536*x^12*y^4
    + 44*x^12*y^3 - 5*x^12*y^2 + x^12*y + 10*x^11*y^24 + 18*x^11*y^23 - 
    320*x^11*y^22 - 940*x^11*y^21 - 2390*x^11*y^20 + 3714*x^11*y^19 + 
    1247*x^11*y^18 + 12800*x^11*y^17 - 15895*x^11*y^16 + 11851*x^11*y^15 - 
    39111*x^11*y^14 + 27557*x^11*y^13 - 10786*x^11*y^12 + 47254*x^11*y^11 - 
    34500*x^11*y^10 - 8896*x^11*y^9 - 403*x^11*y^8 + 13887*x^11*y^7 - 
    4429*x^11*y^6 - 899*x^11*y^5 + 149*x^11*y^4 + 91*x^11*y^3 - 11*x^11*y^2 + 
    x^11*y - 10*x^10*y^24 + 18*x^10*y^23 + 172*x^10*y^22 + 1060*x^10*y^21 + 
    5*x^10*y^20 - 756*x^10*y^19 - 7267*x^10*y^18 + 5429*x^10*y^17 - 
    4624*x^10*y^16 + 21096*x^10*y^15 - 17894*x^10*y^14 + 19751*x^10*y^13 - 
    33986*x^10*y^12 + 4688*x^10*y^11 + 15678*x^10*y^10 + 6465*x^10*y^9 - 
    7386*x^10*y^8 - 7308*x^10*y^7 + 4110*x^10*y^6 + 1867*x^10*y^5 - 
    1276*x^10*y^4 + 184*x^10*y^3 - 17*x^10*y^2 + x^10*y + 5*x^9*y^24 - 
    7*x^9*y^23 - 145*x^9*y^22 - 553*x^9*y^21 + 65*x^9*y^20 + 1463*x^9*y^19 + 
    3148*x^9*y^18 - 3031*x^9*y^17 - 3640*x^9*y^16 - 2528*x^9*y^15 + 
    5071*x^9*y^14 - 4688*x^9*y^13 + 21557*x^9*y^12 - 23107*x^9*y^11 + 
    12572*x^9*y^10 - 22352*x^9*y^9 + 23779*x^9*y^8 - 6053*x^9*y^7 - 1756*x^9*y^6
    - 639*x^9*y^5 + 993*x^9*y^4 - 132*x^9*y^3 - 23*x^9*y^2 + x^9*y - x^8*y^24 - 
    8*x^8*y^23 + 122*x^8*y^22 + 110*x^8*y^21 + 447*x^8*y^20 - 2604*x^8*y^19 + 
    2130*x^8*y^18 - 4195*x^8*y^17 + 14810*x^8*y^16 - 21381*x^8*y^15 + 
    27161*x^8*y^14 - 40768*x^8*y^13 + 46115*x^8*y^12 - 46077*x^8*y^11 + 
    47004*x^8*y^10 - 32761*x^8*y^9 + 13928*x^8*y^8 - 9223*x^8*y^7 + 7821*x^8*y^6
    - 2540*x^8*y^5 - 360*x^8*y^4 + 298*x^8*y^3 - 29*x^8*y^2 + x^8*y + 4*x^7*y^23
    - 28*x^7*y^22 - 178*x^7*y^21 + 280*x^7*y^20 - 153*x^7*y^19 + 2868*x^7*y^18 -
    7799*x^7*y^17 + 11450*x^7*y^16 - 20871*x^7*y^15 + 37132*x^7*y^14 - 
    47503*x^7*y^13 + 50801*x^7*y^12 - 48458*x^7*y^11 + 36834*x^7*y^10 - 
    25174*x^7*y^9 + 18902*x^7*y^8 - 11029*x^7*y^7 + 3320*x^7*y^6 - 923*x^7*y^5 +
    915*x^7*y^4 - 461*x^7*y^3 + 70*x^7*y^2 + x^7*y - 6*x^6*y^22 + 102*x^6*y^21 -
    93*x^6*y^20 - 264*x^6*y^19 + 104*x^6*y^18 - 553*x^6*y^17 + 5165*x^6*y^16 - 
    11636*x^6*y^15 + 16058*x^6*y^14 - 21163*x^6*y^13 + 25518*x^6*y^12 - 
    23652*x^6*y^11 + 17982*x^6*y^10 - 12076*x^6*y^9 + 6419*x^6*y^8 - 
    3448*x^6*y^7 + 3084*x^6*y^6 - 2203*x^6*y^5 + 707*x^6*y^4 - 20*x^6*y^3 - 
    26*x^6*y^2 + x^6*y + 4*x^5*y^21 - 148*x^5*y^20 + 565*x^5*y^19 - 926*x^5*y^18
    + 1535*x^5*y^17 - 3578*x^5*y^16 + 5680*x^5*y^15 - 5546*x^5*y^14 + 
    5335*x^5*y^13 - 7017*x^5*y^12 + 7965*x^5*y^11 - 6773*x^5*y^10 + 4679*x^5*y^9
    - 2222*x^5*y^8 + 194*x^5*y^7 + 518*x^5*y^6 - 499*x^5*y^5 + 437*x^5*y^4 - 
    292*x^5*y^3 + 103*x^5*y^2 - 14*x^5*y - x^4*y^20 + 133*x^4*y^19 - 
    819*x^4*y^18 + 2357*x^4*y^17 - 4745*x^4*y^16 + 8692*x^4*y^15 - 
    14705*x^4*y^14 + 20527*x^4*y^13 - 23075*x^4*y^12 + 22036*x^4*y^11 - 
    18506*x^4*y^10 + 13206*x^4*y^9 - 7517*x^4*y^8 + 3134*x^4*y^7 - 667*x^4*y^6 -
    235*x^4*y^5 + 266*x^4*y^4 - 91*x^4*y^3 + 9*x^4*y^2 + x^4*y - 84*x^3*y^18 + 
    672*x^3*y^17 - 2478*x^3*y^16 + 5815*x^3*y^15 - 10310*x^3*y^14 + 
    15307*x^3*y^13 - 19456*x^3*y^12 + 20558*x^3*y^11 - 17584*x^3*y^10 + 
    12110*x^3*y^9 - 6717*x^3*y^8 + 2931*x^3*y^7 - 922*x^3*y^6 + 143*x^3*y^5 + 
    50*x^3*y^4 - 56*x^3*y^3 + 28*x^3*y^2 - 8*x^3*y + x^3 + 36*x^2*y^17 - 
    333*x^2*y^16 + 1412*x^2*y^15 - 3680*x^2*y^14 + 6715*x^2*y^13 - 9312*x^2*y^12
    + 10356*x^2*y^11 - 9444*x^2*y^10 + 6990*x^2*y^9 - 4065*x^2*y^8 + 
    1776*x^2*y^7 - 548*x^2*y^6 + 107*x^2*y^5 - 10*x^2*y^4 - 9*x*y^16 + 92*x*y^15
    - 429*x*y^14 + 1210*x*y^13 - 2310*x*y^12 + 3168*x*y^11 - 3234*x*y^10 + 
    2508*x*y^9 - 1485*x*y^8 + 660*x*y^7 - 209*x*y^6 + 42*x*y^5 - 4*x*y^4 + y^15 
    - 11*y^14 + 55*y^13 - 165*y^12 + 330*y^11 - 462*y^10 + 462*y^9 - 330*y^8 + 
    165*y^7 - 55*y^6 + 11*y^5 - y^4;        
return f;
    
end function;

///////////////////////////////////////////////////////////////////////////////////////////////////////////

function Eis_k(k,nth,M)
//{the nth coefficient of E_k mod M}
	RM:=Integers(M);
	
	Bk:=BernoulliNumber(k);
	ldc:=-2*k/Bk;
	if nth eq 0 then
		ai:=RM!(1);
	else
		ai:=RM!(ldc*DivisorSigma(k-1,nth));
	end if;
	return Integers()!ai;
end function;

///////////////////////////////////////////////////////

function Delta12(nth,M)
//{nth coefficient of Delta12 Delta12:=(e4*e8-e6^2);}
	RM:=Integers(M);
	
	ldc:=Eis_k(4,0,M)*Eis_k(8,1,M)-Eis_k(6,0,M)*Eis_k(6,1,M)+Eis_k(4,1,M)*Eis_k(8,0,M)-Eis_k(6,1,M)*Eis_k(6,0,M);
	
	ai:=RM!0;
	for i:=0 to nth do
		j:=nth-i;
		ai:=ai+Eis_k(4,i,M)*Eis_k(8,j,M)-Eis_k(6,i,M)*Eis_k(6,j,M);
	end for;
	
	ai:=ai/ldc;
	
	return Integers()!ai;
end function;

///////////////////////////////////////////////

function Delta16(nth,M)
//{nth coefficient of Delta16:=Delta12*e4;}
	RM:=Integers(M);
	
	ldc:=Delta12(0,M)*Eis_k(4,1,M)+Delta12(1,M)*Eis_k(4,0,M);
	
	ai:=RM!0;
	for i:=0 to nth do
		j:=nth-i;
		ai:=ai+Delta12(i,M)*Eis_k(4,j,M);
	end for;
	
	ai:=ai/ldc;
	
	return Integers()!ai;
end function;

/////////////////////////////////////////////

function Delta18(nth,M)
//{nth coefficient of Delta18:=Delta12*e6;}
	RM:=Integers(M);
	
	ldc:=Delta12(0,M)*Eis_k(6,1,M)+Delta12(1,M)*Eis_k(6,0,M);
	
	ai:=RM!0;
	for i:=0 to nth do
		j:=nth-i;
		ai:=ai+Delta12(i,M)*Eis_k(6,j,M);
	end for;
	
	ai:=ai/ldc;
	
	return Integers()!ai;
end function;

///////////////////////////////////////////

function Delta20(nth,M)
//{nth coefficient of Delta20:=Delta12*e8;}
	RM:=Integers(M);
	
	ldc:=Delta12(0,M)*Eis_k(8,1,M)+Delta12(1,M)*Eis_k(8,0,M);
	
	ai:=RM!0;
	for i:=0 to nth do
		j:=nth-i;
		ai:=ai+Delta12(i,M)*Eis_k(8,j,M);
	end for;
	
	ai:=ai/ldc;
	
	return Integers()!ai;
end function;

////////////////////////////////////////////

function Delta22(nth,M)
//{nth coefficient of Delta22:=Delta12*e10;}
	RM:=Integers(M);
	
	ldc:=Delta12(0,M)*Eis_k(10,1,M)+Delta12(1,M)*Eis_k(10,0,M);
	
	ai:=RM!0;
	for i:=0 to nth do
		j:=nth-i;
		ai:=ai+Delta12(i,M)*Eis_k(10,j,M);
	end for;
	
	ai:=ai/ldc;
	
	return Integers()!ai;
end function;

//////////////////////////////////////////////////////////////////////////////////////////////////////////

function Tau_k_p(p,k,ell)
//{compute tau_k(p) for k in [12,16,18,20,22] }
	if k eq 12 then
		return Delta12(p,ell);
	elif k eq 16 then
		return Delta16(p,ell);
	elif k eq 18 then
		return Delta18(p,ell);
	elif k eq 20 then
		return Delta20(p,ell);
	elif k eq 22 then
		return Delta22(p,ell);
	else
		error"k not in [12,16,18,20,22]";
	end if;		
end function;

//////////////////////////////////////////////////////////////////////////////////////////////////////////

function PhiSet_and_Piset(Mod_As,k,l)
//{return phi_S:JH(l,index)->A_(f,k),x|-> T_n(x), S=n and pi_S:A_(f,k)->V_(k,l), S=m}
	h:=((l-1)) div GCD(l-1,k-2);
	
	R<x>:=PolynomialRing(GF(l));
	
	tau_2:=GF(l)!Tau_k_p(2,k,l);
	
	f2:=R!MinimalHeckePolynomial(JH(l,h),2);
	g2:=R!MinimalHeckePolynomial(Mod_As[#Mod_As],2);

	tau_3:=GF(l)!Tau_k_p(3,k,l);
	
	f3:=R!MinimalHeckePolynomial(JH(l,h),3);
	g3:=R!MinimalHeckePolynomial(Mod_As[#Mod_As],3);
	
		
	if (f2 mod (x-tau_2)^2) ne 0 then
		return 2,2;
	elif (f3 mod (x-tau_3)^2) ne 0 then	
		return 3,3;
	elif (f2 mod (x-tau_3)) ne 0 and (g3 mod (x-tau_3)^2) ne 0 then
		return 2,3;
	elif (f3 mod (x-tau_2)) ne 0 and (g2 mod (x-tau_2)^2) ne 0 then	
		return 3,2;
	else
		error"decide this case use more Hecke operators";
	end if;
	
end function;

/////////////////////////////////////////////////////////////////////////////////////////////////

function Afkl(k,ell)
//{decomposte JH(l,h) and find Afkl which V_k_l lies in}

h:=((ell-1)) div GCD(ell-1,k-2);

As:=Decomposition(JH(ell,h));

Delta_q:=Reductions(Newforms(CuspidalSubspace(ModularForms(Gamma1(1),k)))[1][1],ell)[1][1];

n_k_l:=[];


//recording the newforms of level ell weight 2
M_set:=<>;
for i:=1 to #As do
	Mmodell:=Reductions(Newform(As[i]),ell);
	
	for j:=1 to #Mmodell do
		for k:=1 to #Mmodell[j] do
			Append(~M_set,Mmodell[j][k]);
			
			if Degree(Delta_q) eq Degree(Mmodell[j][k]) then
				tf:=true;
				for z:=1 to 100 do
					if Coefficient(Delta_q,z) ne  Coefficient(Mmodell[j][k],z) then
						tf:=false;
						break;
					end if;
				end for;
				
				if tf then
					Append(~n_k_l,i);
					//"Delta(q)",Delta_q,"=",Mmodell[j][k],"mod",ell;
					//As[i];
					//"f",Newform(As[i]);
					//"Dim A_f_k_l=",Dimension(As[i]);
				end if;				
			end if;
		end for;					
	end for;				
end for;


if #n_k_l ne 1 then error"Delta_q not congruent to any f in S_2(\Gamma1(l)) why!!!";end if;


Mod_As:=[];

for i:=1 to #As do
	if i ne n_k_l[1] then Append(~Mod_As,As[i]);end if;
end for;

Append(~Mod_As,As[n_k_l[1]]);

return Mod_As;

end function;

///////////////////////////////////////////////////////////////////////////////////////////////////////////

function OrdPoly(f,g)
//{return ord_g(f)}
   n:=0;
   while true do
     if (f mod g^n) eq 0 and (f mod g^(n+1)) ne 0 then      	     	
     	 break;
     	end if;
      n:=n+1;
   end while;
  return n;
end function;

/////////////////////////////////////////////////////////////////////////////////////////////////

function AnBnCnen(Afkl,n,l,k)
//{compute the characteristic poly of  ecke operator T_n acting S_2(Gamma1(l)) An, factor it and return An,Bn,en where An=Bn (X-tau_k(n))^en}

  P<x>:=PolynomialRing(GF(l));
  An:=P!MinimalHeckePolynomial(Afkl,n);	
  
  Cn:=P!(x-Tau_k_p(n,k,l));
  
  en:=OrdPoly(An,Cn);
  	
  if en lt 1 then error"the exponent en should not less than one!";end if;	
  
  Bn:=An div (Cn^en);
  Cn:=P!(x-Tau_k_p(n,k,l));
  		
  return An,Bn,Cn,en;
  			
end function;

///////////////////////////////////////////////////////////////////////////////////////

function DChar(FF)
/*
{Given a newform FF return the value of The Dirichlet character chi:ZZ div n ZZ ->C* associated to F
as a sequence [chi(1),chi(2),...,chi(n-1)], use the formula chi(p)=(a_p^2-a_(p^2)) div p 
and chi(mn)=chi(m)*chi(n)
be careful we can not compute chi(l) where l<=n-1 is the character of the base field!
use the equality chi(l)=chi(l+n) instead.
}
*/

	n:=Level(FF);
	
	RR:=BaseField(FF);
	
	ell:=Characteristic(RR);
	
	Chars:=[RR!0: i in [1..n-1]];
	Chars[1]:=1;
		
	p:=2;
	
	while true do
	  if p gt n-1 then break;end if;
	  
	  //except the special point
	  
	  if p ne ell then
	  	//"p",p;
	  	Chars[p]:=(Coefficient(FF,p)^2-Coefficient(FF,p^2))/p;
	  	//"Chars[p]=",Chars[p];
	  end if;
	  
	  p:=NextPrime(p);
	  
	   
	end while;
	//Chars;
	//Type(Chars[2]);
	
	for i:=1 to n-1 do
	  
	  if i eq ell then//special point
	  	facs:=Factorization(i+n);
	  	tmp:=1;
	  	for j:=1 to #facs do
	  		tmp:=tmp*(Chars[facs[j][1]]^(facs[j][1]));
	  	end for;
	  	Chars[i]:=tmp;
	  else
	  
	  	facs:=Factorization(i);
	        //"facs",facs;
	        
	  	tmp:=1;
	  	for j:=1 to #facs do
	  		tmp:=tmp*(Chars[facs[j][1]]^(facs[j][2]));
	  	end for;
	  	Chars[i]:=tmp;
	  
	  end if;
	
	end for;
	
	return Chars;
end function;

/////////////////////////////////////////////////////////////////////////////////////////////////////////

function FrobeniusPolynomialAs(Mod_As,ell,q,h_index)
//{JH(l,h_index)=A1*...*Ak compute the Frobenius  polynomial Fq on A1,...,A_k}
    
  As:=Mod_As;
  "As",As;
  Polys:=<>;
  
  for i:=1 to #As do
  	f_i:=Newform(As[i]);
  	chi_i:=DirichletCharacter(As[i]);
  	Kf:=BaseField(f_i);
  	RR<X>:=PolynomialRing(Kf);
  	
  	//very strange we can not use  MinimalHeckePolynomial(37A[12],q) for q greater than 77773 but
  	//MinimalHeckePolynomial(37A[4],q) works for q near 10^6
  	
  	M_chi_i:=CuspidalSubspace(ModularForms(chi_i,2));
	
	if Dimension(M_chi_i) eq Dimension(As[i]) then	
  		M:=M_chi_i;  		
	else
		M:=As[i];
	end if;
	
  	
  	hkfq:=RR!(HeckePolynomial(M,q));
  	rts1:=Roots(hkfq); 
  	//"rts1",rts1;
  	alpha:=rts1[1][1];  	
  	hkfqq:=RR!(HeckePolynomial(M,q^2));
  	rts2:=Roots(hkfqq);//split completely
  	//"rts2",rts2;
  	nu:=0;
  	
  	//"hkfq",hkfq;
  	//"hkfqq",hkfqq;
  	for j:=1 to #rts2 do
  		  taq:=alpha;
  		  taqq:=rts2[j][1];
  		  tchiq:=(taq^2-taqq)/q;
  		  if  tchiq in DChar(f_i) then
  		     aq:=taq;
  		     chiq:=tchiq;
  		     //"aq aqq chiq",aq,chiq;
  		     nu:=nu+1;  	     
  		  end if;
  	end for;
  	
  	
  	if nu lt 1  then 
  		"nu=",nu;
  		error"matched number should >= 1 !!";
  	end if;
  	
  	c_aq:=Conjugates(alpha);
  	c_chiq:=Conjugates(chiq);
  	
  	TT<y>:=PolynomialRing(ComplexField(200000));
  	
  	myfq:=TT!1;
  	
  	for i:=1 to #c_aq do
 		 myfq:=myfq*(y^2-c_aq[i]*y+q*c_chiq[i]);
  	end for;
  	
  	UU<z>:=PolynomialRing(Integers());
  	
  	myfq_i:=UU!0;
  	
  	for i:=0 to Degree(myfq) do
  		myfq_i:=myfq_i+z^i*(Integers()!Round(Coefficient(myfq,i))); 
  	end for;
  	    	
  	Append(~Polys,myfq_i);
  end for;
   
  return Polys;
  
end function;

///////////////////////////////////////////////////////////////////////////////////////////

function FactorsJHl(Mod_As,p_l_e_h_phis)
/*
{input:reduction prime p ,level of modular curve l,extension degree e,
output:index of component ,<A1,A2,...>,<MinimailPoly(A1,2),...>	}
*/
p:=p_l_e_h_phis[1];
l:=p_l_e_h_phis[2];
e:=p_l_e_h_phis[3];
h_index:=p_l_e_h_phis[4];
phis:=p_l_e_h_phis[5];

ZZ:=IntegerRing();

k:=e;
		
R2<T,U>:=PolynomialRing(ZZ,2);
	
//fx:=FrobeniusPolynomial(JOne(l),p);
fs:=FrobeniusPolynomialAs(Mod_As,l,p,h_index);

fx:=fs[1];
for i:=2 to #fs do
	fx:=fx*fs[i];
end for;


PT:=R2!0;
	
for i:=0 to Degree(fx) do
	  PT:=PT+Coefficient(fx,i)*T^i;
end for;
PTk:= Resultant(PT, T^k-U,T);
NofJOne:=Evaluate(PTk,[1,1]);

"cardinality of JH(l,",h_index,")(Fq)=",NofJOne;

NofallAi:=1;
NofAilist:=<>;	
for i:=1 to #fs do
	PTi:=R2!0;
	fxi:=fs[i];
	for j:=0 to Degree(fxi) do
	  PTi:=PTi+Coefficient(fxi,j)*T^j;
	end for;
	
	PTik:= Resultant(PTi, T^k-U,T);
	NuofAi:=Evaluate(PTik,[1,1]);
	"cardinality of abelian variety A_",i,"(Fq) =",NuofAi;
	NofallAi:=NofallAi*NuofAi;
	Append(~NofAilist,NuofAi);		
end for;		
	
if NofJOne ne NofallAi then 
	error"NofJOne ne NofallAi";
end if; 

//Minimal Hecke 	Polynomails
A:=Mod_As;

HPolylist:=<>;

for i:=1 to #A do
	HkPolyi:=MinimalHeckePolynomial(A[i],phis);
	Append(~HPolylist,HkPolyi);		
end for;
	
return #NofAilist,NofAilist,HPolylist;
	
end function;

//////////////////////////////////////////////////////////////////////////////////////


function CuspIndex(P,Cusps)
/*
{give a cusp P return the position of P in the set of cusps,
as the set is arragned as 1,1/2,.... the return number is the cusps 
represented as 1/? 	
	}
*/
  n:=1;
  while true do
     if P eq Cusps[n] then      	
     	break;
     end if;
     
     n:=n+1;
     			 
  end while;

  if n gt # Cusps then error"input place is not cusp ";end if;
  	
  return n;
  	
end function;

/////////////////////////////////////////////////////////////////////////////////////

function Tqn(q,n,l)
//{ compute q*n=x or -x  mod l where x>0 }

  if (q*n mod l) gt ((l-1)div 2) then 
  	return (l- (q*n mod l));
  else
  	return (q*n mod l);
  end if;	

end function;

///////////////////////////////////////////////////////////////////////////////////////

function diamondcusp(Cusps,Dvr,n,d,Horbits)
//{diamond operators <d> acting on cusp n is the level}
  	 
     supp,exps:=Support(Dvr);
  	     
     D:=Dvr-Dvr;	
  	 	     
     for i:=1 to #supp do
        cusi:=CuspIndex(supp[i],Cusps);
        //"cusi",cusi;
        ddd:=Horbits[cusi][1];
                
        //Tqn(q,n,l);		
        qn:=Tqn(d,ddd,n);
        for j:=1 to #Horbits do
        	if qn in Horbits[j] then
        		qn:=j;
        		break;
        	end if;	       	
        end for;
        
        //"qn",qn;     
        D:=D+ exps[i]*(Cusps[qn]);  
     end for;

     return D;
		
end function;

////////////////////////////////////////////////////////////////////////////////////////

function TqCusp(Cusps,Dvr,q,n,Horbits)
//{compute the action of T_q on a divisor Q wihch contains only cusps Tq(Cusps)=Cusps+q*<q>Cusps}	
	return (Dvr+q*diamondcusp(Cusps,Dvr,n,q,Horbits));     
end function;

////////////////////////////////////////////////////////////////////////////////////////////

function PointSetToPlace(FxFxyF,points)//Fx::FldFunRat,Fxy::FldFun,F::FldFin
/*
{
	 F is the base finite field 
	Input the point set <<x1,y1>,...,<xn,yn>> which is a Galois conjugate set over F;
 
 copmute the  corresponding place of the function field 
 
}
*/
		    n:=#points;
        	    //"points=",points;
		    /*
		     case degree(minimal(x1)) ge degree(minimal(y1))
		     1 x1 x1^2 ... x1^(n-1) b0    -y1
		     1 x2 x2^2 ... x2^(n-1) b1    -y2 
		     ...................... . 
		     1 xn xn^2 ... xn^(n-1)  bn-1  -yn 
		     represent yi's as linear combination of x^i's
		     
		     case degree(minimal(x1)) lt degree(minimal(y1))
		     1 y1 x1^2 ... y1^(n-1) b0    -x1
		     1 y2 x2^2 ... y2^(n-1) b1    -x2 
		     ...................... . 
		     1 yn yn^2 ... yn^(n-1)  bn-1  -xn 
		     represent xi's as linear combination of y^i's		    
		    */
		    Fx:=FxFxyF[1];
		    Fxy:=FxFxyF[2];
		    F:=FxFxyF[3];
		    			
		    x:=Fx.1;
		    y:=Fxy.1;	
		    
		    
		    Fldofx:=MinimalPolynomial(points[1][1],F);
		    Fldofy:=MinimalPolynomial(points[1][2],F);	
		    
		    
		    Ofld:=MaximalOrderFinite(Fxy);
		    
		    if Degree(Fldofx) ge Degree(Fldofy) then 	
		        K:=Parent(points[1][1]);
		        /*	
		        for i:=1 to n do//case l=17
		        	  yy:=points[i][2];
		        	  xx:=points[i][1];
		        	  		
		        	  fxxyy:=yy^4 + (xx^3 + xx^2 - xx + 2)*yy^3 + (xx^3 - 3*xx + 1)*yy^2 - (xx^4 + 2*xx)*yy + xx^3 + xx^2;
		        		if (fxxyy) ne 0 then
		        		     error "error in input point set. the ",i,"-th point wrong.";
		        		end if;	
		        end for;	
            */
   			    //"n=",n;
            R<X> := PolynomialRing(Parent(points[1][1]));
            
            FX:=R!1;
            
            for i:=1 to n do 
            	FX:=FX*(X-points[i][1]);    	
            end for;	
            
            disf:=Discriminant(FX);
		        //disf;
		        coeseq:=[[ points[j][1]^i : i in [0..n-1] ]:j in [1..n]];	
		        	
		        XM := Matrix(K, n, n, coeseq);
		        	
		        disM:=Determinant(XM)^2;
		        
		        if disM eq 0 then
		        	 "base field=",K;
		        	 "points=",points;
		        	 "XM=",XM;
		        	 error"the matrix is not invertible check the point set!";
		        end if;
		        //XM;	
		        if disf ne disM then error"what happen?";end if;	
		        		
		        invXM:=XM^(-1);
		        coeseq:=[-points[i][2]:i in [1..n]];	
		        YM:=	Matrix(K, n, 1, coeseq);
            B:=invXM*YM;
            
            geny:=y;
            
            for i:=1 to n do
            	
            		coeff:=MinimalPolynomial(B[i][1],F);
            			
            		if Degree(coeff) ne 1 then 
            		  "F=",F;
            		  "coeff=",coeff;	
            			error "error here 186 in pointSetToPlace";            			
            		end if;
            	
            		geny:=geny-Coefficient(coeff,0)*x^(i-1);
            	
            end for;
            //geny;
            		
            genx:=x^n;
            	    
            for i:=0 to n-1 do
            	ai:=Coefficient(FX,i);
            	coeff:=MinimalPolynomial(ai,F);
            	if Degree(coeff) ne 1 then error "error here";end if;
            		
            	genx:=genx-Coefficient(coeff,0)*x^(i);
            		
            end for;
            //"genx",genx;
            //"geny",geny;
            //"Fxy",Fxy;
            
            CSS:=CommonZeros(Fxy,[genx,geny]);
            if #CSS gt 1 then error"not a place"; end if;
            pls:=CSS[1];
         else
	    K:=Parent(points[1][2]);   	   
            R<Y> := PolynomialRing(Parent(points[1][2]));            
            FY:=R!1;
            
            for i:=1 to n do 
            	FY:=FY*(Y-points[i][2]);    	
            end for;	
            
            disf:=Discriminant(FY);
		        //disf;
		        coeseq:=[[ points[j][2]^i : i in [0..n-1] ]:j in [1..n]];	
		        	
		        YM := Matrix(K, n, n, coeseq);
		        	
		        disM:=Determinant(YM)^2;
		        
		        if disM eq 0 then
		        	 //"base field=",K;
		        	 //"points=",points;
		        	 //"YM=",YM;
		        	 error"the matrix is not invertible check the point set!";
		        end if;
		        //XM;	
		        if disf ne disM then
		        	//"base field=",K;
		        	 //"points=",points;
		        	 //"YM=",YM;
		        	 disM;
		        	 disf;
		        	 FY;
		        	  
		        	error"what happen disf should equal to disM";
		        end if;	
		        		
		        invYM:=YM^(-1);
		        	
		        coeseq:=[-points[i][1]:i in [1..n]];	
		        YM:=	Matrix(K, n, 1, coeseq);
            B:=invYM*YM;
            
            genx:=x;
            
            for i:=1 to n do
            	
            		coeff:=MinimalPolynomial(B[i][1],F);
            			
            		if Degree(coeff) ne 1 then error "error here";end if;
            	
            		genx:=genx-Coefficient(coeff,0)*y^(i-1);
            	
            end for;
            //geny;
            		
            geny:=y^n;
            	    
            for i:=0 to n-1 do
            	ai:=Coefficient(FY,i);
            	coeff:=MinimalPolynomial(ai,F);
            	if Degree(coeff) ne 1 then error "error here";end if;
            		
            	geny:=geny-Coefficient(coeff,0)*y^(i);
            		
            end for;
	     CSS:=CommonZeros(Fxy,[genx,geny]);
             if #CSS gt 1 then error"not a place"; end if;
             pls:=CSS[1];                     	
        end if;	    	
        return pls;	
	  
            	
end function;

///////////////////////////////////////////////////////////////////////////////////////

function TateNormalForm(E,usdpt,l)
//{ computing Tate normal form }
	
	K:=CoefficientRing(E);
  i:=0;

  if IsOrder(usdpt,l) eq false then error "error occur!";end if;

	x0:=usdpt[1];
	y0:=usdpt[2];

	a1,a2,a3,a4,a6:=Explode(aInvariants(E));	
	aa1:=a1;
	aa3:=2*y0+a3+a1*x0;
	aa2:=3*x0+a2;
	aa4:=3*x0^2+2*x0*a2+a4-a1*y0;
	aa6:=0;
	aaa1:=2*aa4/aa3+aa1;
	aaa3:=aa3;
	aaa2:=aa2-(aa4/aa3)^2-aa1*aa4/aa3;
	aaa4:=0;
	aaa6:=0;
	
	fff:=aaa2^3/aaa3^2;
	ggg:=(aaa1*aaa2-aaa3)/aaa3;
	
	Etate:=EllipticCurve([1+ggg,fff,fff,0,0]);

  return Etate;
end function;

//////////////////////////////////////////////////////////////////////////////////

function PlaceToPoint(F,P)
//{give a place P return one of point in the conjugate set of points representes P}

	Fldplc1:=P;
	//"P",P;  
	DgoFldplc1:=Degree(Fldplc1);
        gen1,gen2:=TwoGenerators(Fldplc1);//type FldFunElt
        elegen1:=ElementToSequence(gen1);//?+?*y+?*y^2+...+?*y^(d-1) ,d=degree of modular curve
        elegen2:=ElementToSequence(gen2);//type is SeqEnum
        	
        polgen1:=Numerator(elegen1[1]);//type RngUPolElt
        
        BsFld:=Parent(Coefficient(polgen1,0));
        //"BsFld",BsFld;
        //"F",F;
        if BsFld ne F then error"the definition field of input place should equal to the base field";end if;	
        //"--------------";
        //BsFld;
        for i:=1 to #elegen1 do	
        	if Denominator(elegen1[i]) ne 1 then 
        		return false,0,0;
        		//error "generator of the place is of uncontroled form drop it!!!!";
        	end if;
        end for;
        
        for i:=1 to #elegen2 do	
        	if Denominator(elegen2[i]) ne 1 then
        		return false,0,0; 
        		//error "generator of the place is of uncontroled form drop it!!!!";
        	end if;
        end for;        
        
        for i:=2 to #elegen1 do
        	if elegen1[i] ne 0 then error"place of x-part shouls be x^...";end if;
        end for;				

        //check the place and calculate some paremeters
        if Degree(polgen1) lt DgoFldplc1 then
        	//in this case degree of y is bigger than one,so we hope x-part to be x+*
        	  if Degree(polgen1) ne 1 then error"why has this case!?";end if;
        end if;
        
        nn0:=0;	
        for i:=0 to #elegen2 do//*y^0+*y^1+...+*y^nn0+0 find nn0
           if elegen2[#elegen2-i] ne 0 then 
           	 nn0:=#elegen2-i;
           	break;
           end if;
        end for;			 
        
        if Degree(polgen1) lt DgoFldplc1 then 
        	if (nn0-1) ne DgoFldplc1 then//in this case degree of y should equal to degree of the place!
        		elegen2;
        		#elegen2;
        		nn0;
        		error"in this case the degree of y should equal to degree of the place";
        	end if;        			
        	//error"becarefull the degree of elegen2 is bigger than 1";
        end if;
        //end of check the place 
        
        rts,_:=RootsInSplittingField(polgen1);
        			
        x_pt1:=rts[1][1];
                                      
        //two possible cases
        if Degree(polgen1) eq DgoFldplc1 then//(x^d+...+*,*y+*)
          fele1:=elegen2[1];
          fele2:=elegen2[2];
          
          //"fele1,fele2",fele1,fele2;
          //"x_pt1",x_pt1;
          if Evaluate(fele2,x_pt1) eq 0 then
            error"deno is zero!";
          end if;	
          y_pt1:=-Evaluate(fele1,x_pt1)/Evaluate(fele2,x_pt1);// only works for *y+?x^2+...
        else//(x+*,*y^d+...)
        	
        	POLYTP<t>:=PolynomialRing(BsFld);
        	fy:=POLYTP!0;		
        	for i:=1 to nn0 do
        			poly2:=Numerator(elegen2[i]);
        			if Denominator(elegen2[i]) ne 1 then error"the poly should be one";end if;
        			/*
        			if Degree(poly2) ne 0 then 
        				"Degree(poly2)",Degree(poly2);
        				"poly2",poly2;
        				error"the degree of poly should be 0";
        			end if;
        			a0:=Coefficient(poly2,0);
        			*/
        			a0:=Evaluate(poly2,x_pt1);
        			
        			fy:=fy+a0*t^(i-1);	        							
        	end for;
        			
        	//"fy",fy;
        	//Type(fy);        	
        	rts,_:=RootsInSplittingField(fy);
        	y_pt1:=rts[1][1];
        	//rts;
        	//y_pt1;			
        	//error"stop";
        end if;
        //"===============";	
        return true,x_pt1,y_pt1;	
end function;

/////////////////////////////////////////////////////////////////////////////////

function Polyofbc(bc,F)
//{compute the minimal poly. of (b,c)}
          //"Polyofbc MinimalPolynomial";
          charfb:=MinimalPolynomial(bc[1],F);
	      		
	      	charfc:=MinimalPolynomial(bc[2],F);
	      	
	      	db:=Degree(charfb);
	      	dc:=Degree(charfc);	
	      				
	      	if db ge 	dc then
	      		 if (db mod dc) ne 0 then error"dc should be adivisor of db";end if;
	      		 minpoly:=charfb;
	      	else
	      		 if (dc mod db) ne 0 then error"dc should be adivisor of db";end if;
	      		 minpoly:=charfc;	
	      	end if;
		return minpoly;
end function;

///////////////////////////////////////////////////////////////////////////////////////////

function Tupinornot(a,b)
//{a=<*,*,*> in or not b=<<*,*,*>,<*,*,*>...> }

  flag:=1;
  for i:=1 to #b do 
  	
     if a eq b[i] then 
     	flag:=0;   		
     	break;
     end if;
     	 	
  end for;
  
  if flag eq 0 then return true;
  else 
  	//"a",a;
  	//"b",b;
  	return false;
  end if;				
end function;

//////////////////////////////////////////////////////////////////////////////////////////

function EvaluteX1(x,y)
//{check whether f(x,y)=0 plane equation for X_1(ell)}
   
   l:=XHldata()[2][2];
   
   f:=EquationsForX1()[l-1];
   
   if Evaluate(f,[x,y]) eq 0 then return true;
   else return false;
   end if; 
end function;

///////////////////////////////////////////////////////////////////////////////////////

function EvaluteXH(X,Y)
//{check whether F(X,Y)=0  plane equation for X_H(ell)}

   XHl:=XHldata()[1][1];
   
   if Evaluate(XHl,[X,Y]) eq 0 then return true;
   else return false;
   end if; 
end function;

/////////////////////////////////////////////////////////////////////////////////////////

function AbovePoint(XYroots)
//{given a point P in XH31 return one of the 5 points in Xone31 above P, work with plane curves}
  
  U:=XYroots[1];
  V:=XYroots[2];
  
   if EvaluteXH(U,V) eq false then 
      error"XHl(U,V)!=0";
   end if;
  //check end
  
  
  
FFX:=Parent(U);
FFY:=Parent(V);
if #FFX gt #FFY then
  FF:=FFX;
else
   FF:=FFY;
end if;

  XxXyYxYy:=PolyXxXyYxYy();
  Xx:=PolynomialRing(FF,2)!XxXyYxYy[1];
  Xy:=PolynomialRing(FF,2)!XxXyYxYy[2];
  Yx:=PolynomialRing(FF,2)!XxXyYxYy[3];
  Yy:=PolynomialRing(FF,2)!XxXyYxYy[4];

//U=X V=Y x=a y=b 

POL<x>:=PolynomialRing(FF);
Ux:=POL!UnivariatePolynomial(Evaluate(Xx,Parent(Xx).1,U));
Vx:=POL!UnivariatePolynomial(Evaluate(Yx,Parent(Yx).1,V));

POL<y>:=PolynomialRing(FF);
Uy:=POL!UnivariatePolynomial(Evaluate(Xy,Parent(Xy).1,U));
Vy:=POL!UnivariatePolynomial(Evaluate(Yy,Parent(Yy).1,V));

gcdXH31fxXxY:=Gcd(Ux,Vx);
//gcdXH31fxXxY;

gcdXH31fyXyY:=Gcd(Uy,Vy);
//gcdXH31fyXyY;

rootsx,FFx:=RootsInSplittingField(gcdXH31fxXxY);
rootsy,FFy:=RootsInSplittingField(gcdXH31fyXyY);

/*
find the pair (x,y) in (rootsx,rootsy) which is a root of X31
*/

rootxy:=<>;

for i:=1 to #rootsx do
	flag:=false;
    for j:=1 to #rootsy do
    	 ta:=rootsx[i][1];
    	 	 tb:=rootsy[j][1];                    
        if EvaluteX1(ta,tb) then
          Append(~rootxy,<ta,tb>);                    
        end if;
        
    end for;
    
end for; 

if #rootxy eq 0 then "no solution!!? why",#rootxy;end if;

return  rootxy[1];

end function;

////////////////////////////////////////////////////////////////////////////////

function UnderPoint(xyroots)
//{(x,y)on Xone(l) use the map X(x,y) and Y(x,y) we have a point on XH(l)}

   //check X31(x,y)=0;
   x:=xyroots[1];
   y:=xyroots[2];
   
   if EvaluteX1(x,y) eq false then error"fl(x,y)!=0";end if;
   
   X:=XHldata()[1][2];
   Y:=XHldata()[1][3];
   fls:=EquationsForX1();
   U:=1;
   V:=1;
   
   for i:=1 to #X do   	
   	if X[i] ne 0 then U:=U*(Evaluate(fls[i],[x,y]))^X[i];end if;
   	
   	if Y[i] ne 0 then V:=V*(Evaluate(fls[i],[x,y]))^Y[i];end if;
   end for;		

   if EvaluteXH(U,V) eq false then error"FUV(U,V)!=0 229";end if;
      
   return <U,V>;
   
end function;

///////////////////////////////////////////////////////////////////

function T2Place(FxFxyF,p_q_l,P)
//{compute T2(P)}
	Fx:=FxFxyF[1];
	Fxy:=FxFxyF[2];
  	F:=FxFxyF[3];
		    		      		
	p:=p_q_l[1];//character
	q:=p_q_l[2];//T_q
	l:=p_q_l[3];//l-torsion
	
	Rts:=<>;
	      
	num:=#F;
	      	
	DgoFldplc1:=Degree(P);
	//"Place P",P;
	tf,X,Y:=PlaceToPoint(F,P);
        if Degree(Parent(X)) ge Degree(Parent(Y))then
           FFXY:=(Parent(X));
        else
           FFXY:=(Parent(Y));
        end if;
        //"X,Y",X,Y;
	//"Parent(X,Y)",FFXY;
	if Degree(FFXY,F) ne DgoFldplc1 then error"Degree(FFXY,F) ne DgoFldplc1 645";end if;
	//"place to point (X,Y)",X,Y;
	 
	if tf eq false then return false,0;end if;
	
	time rootsxy:=AbovePoint(<X,Y>);
	"time AbovePoint";
			 	
	u:=rootsxy[1];
	v:=rootsxy[2];
	
	//"Parent(u)",Parent(u);
	//"Parent(v)",Parent(v);
	      	
	//coordinate change
	r:=(u^2*v-u*v+v-1)/(u^2*v-u);
	s:=(u*v-v+1)/(u*v);
	c:=s*(r-1);
	b:=r*c;			
	
  	E:=EllipticCurve([1-c,-b,-b,0,0]);//Y^2+(1-c)xy-by=X^3-bx^2
	//E1;
	//Order(E1);

  	if IsSingular(E) eq true then   	
  		"the elliptic curve is singular" ;
  		return false,<0,0>;
  	end if;
  	
  	if IsSupersingular(E) eq true then 
  		"the elliptic curve is supersingular";
  		return false,<0,0>;
  	end if;
    	 
  	K:=BaseRing(E);
	//K;
	f2:=DivisionPolynomial(E,2);
	Num:=#K;
		
	//case irreducible
	if IsIrreducible(f2) then	//000000	
		"case irreducible";
  		L:=ext<K|3>;
  		Eext:=BaseChange(E,L);	
  		//"----1---factoring poly --";		
  		fts:=Factorization(PolynomialRing(L)!f2);
  		ker1:=fts[1][1];//select on kernel
  		
  		//"Eext",Eext;
  		//"ker1",ker1;
  		//"----2---- IsogenyFromKernel -";	
		F1_1,map:=IsogenyFromKernel(Eext,ker1);			
		pt:=Eext![0,0,1];
		imgpt:=map(pt);	
		//error"stop";	
		
    		//"--------------------- 6-1 ---------------------------";
    		//"----3---- TateNormalForm -";   	
    		TateF1:=TateNormalForm(F1_1,imgpt,l);
    		//"Tate normal form:",TateF1;
		//"--------------------- 7 ---------------------------";
		a1,a2,a3,a4,a6:=Explode(aInvariants(TateF1));
			
		//Y^2+a1*xy+a3*Y=X^3+a2*X^2+a4*X+a6
			
		if (a4 ne 0) or (a6 ne 0) or (a3 ne a2) then 
				error"the result elliptic curve is not in needed form!";
		end if;
					
		//using galois theory to deduce the other two elliptic curves
				
        	
   			c:=1-a1;
   			b:=-a3;
   			r29:=b/c;
   			s29:=c/(r29-1);
   			X:=(s29-r29)/(r29*s29-2*r29+1);
   			Y:=(r29*s29-2*r29+1)/(s29^2-s29-r29+1);
					
			if EvaluteX1(X,Y) eq false then error"fl!=0 729";end if;
			        	
		tmp:=UnderPoint(<X,Y>);
		ixx:=tmp[1];
		iyy:=tmp[2];
			      	          
		if Degree(Parent(ixx)) ge Degree(Parent(iyy))then
		   FFixxiyy:=Parent(ixx);
		else
		    FFixxiyy:=Parent(iyy);
		end if;
		
		//"parent(ixx,iyy)",FFixxiyy;
		
		dixx:=MinimalPolynomial(ixx,FFXY);
		diyy:=MinimalPolynomial(iyy,FFXY);
		
		if dixx ge diyy then
		  FFixxiyy:=ext<FFXY | dixx>;
		else
		  FFixxiyy:=ext<FFXY | diyy>;
		end if;
		
		//"exact parent(ixx,iyy)",FFixxiyy;       	          
		
		//"under point (ixx,iyy)",ixx,iyy;
		
		ddi:=Degree(FFixxiyy,FFXY);   
		
		if ddi ne 3 then error"irreducible case, extension degree should be 3 ";end if;
		       	                     	                 	          
		tmpnum:=#FFXY;
		 	      		
		for ii:=0 to ddi-1 do
		      Append(~Rts,<ixx^(tmpnum^ii),iyy^(tmpnum^ii)>);	
		end for;   	  										
			
	
	else//000000 case f2=(X-alph)*g, degree(g) eq 2 irreducible //11111
		//"----1---- Factorization(f2) -";
		ftsss:=Factorization(f2);
			
		if #ftsss eq 2 then//case f2=(X-alph)*g, degree(g) eq 2 irreducible //11111
	    	"case degree two irreducible poly";
	    	//"f2=",f2;
	    	//"Factorization(f2)",Factorization(f2);
	    	//"----1---- Factorization(f2) -";
	    	fts:=ftsss;
	  	if Degree(fts[1][1]) eq 1 then	
	  		pol1:=fts[1][1];
	  		pol2:=fts[2][1];		
	     	else
	  		pol1:=fts[2][1];
	  		pol2:=fts[1][1];	     	
	     	end if;
	     		     	
	     	//first isogeny curve
	     	//"---2-- IsogenyFromKernel";		     
	     	F1_1,map:=IsogenyFromKernel(E,pol1);			
		pt:=E![0,0,1];
		imgpt:=map(pt);	
		//error"stop";	
	     
       		//"--------------------- 6-1 ---------------------------";
       		//"---3---TateNormalForm";   	
       		TateF1:=TateNormalForm(F1_1,imgpt,l);
       		//"Tate normal form:",TateF1;
		//"--------------------- 7 ---------------------------";
		a1,a2,a3,a4,a6:=Explode(aInvariants(TateF1));
		   
		//Y^2+a1*xy+a3*Y=X^3+a2*X^2+a4*X+a6
		   
		if (a4 ne 0) or (a6 ne 0) or (a3 ne a2) then 
		   	error"the result elliptic curve is not in needed form!";
		 end if;	
	     
	
	   		c:=1-a1;
	   		b:=-a3;
	   		r29:=b/c;
	   		s29:=c/(r29-1);
	   		X:=(s29-r29)/(r29*s29-2*r29+1);
	   		Y:=(r29*s29-2*r29+1)/(s29^2-s29-r29+1);
			
			   if EvaluteX1(X,Y) eq false then error"fl!=0 815";end if;
 	          
 	        tmp:=UnderPoint(<X,Y>);
       	        ix:=tmp[1];
       	        iy:=tmp[2];
       	               	                	          
       	        if Degree(Parent(ix)) ge Degree(Parent(iy))then
       	           FFixxiyy:=Parent(ix);
       	        else
       	           FFixxiyy:=Parent(iy);
       	        end if;
       	        
       	        //"parent(ix,iy)",FFixxiyy;

       	        dixx:=MinimalPolynomial(ix,FFXY);
       	        diyy:=MinimalPolynomial(iy,FFXY);

       	        if dixx ge diyy then
       	          FFixxiyy:=ext<FFXY | dixx>;
       	        else
       	          FFixxiyy:=ext<FFXY | diyy>;
       	        end if;
       	        
       	        //"exact parent(ixx,iyy)",FFixxiyy;       	          
       	        
       	        //"under point (ixx,iyy)",ixx,iyy;
       	        
       	        ddi:=Degree(FFixxiyy,FFXY);   
       	        if ddi ne 1 then error"degree 1 * degree 2, first root extension degree should be 1 ";end if;       	                     	                 	          
       	        tmpnum:=#FFXY;
       	         	      		
	        for ii:=0 to ddi-1 do
	              Append(~Rts,<ix^(tmpnum^ii),iy^(tmpnum^ii)>);	
	        end for;	 
	  	
	  	
	  	//two conjugate set->elliptic curves


		L:=ext<K|2>;
  		Eext:=BaseChange(E,L);
  		//"---4--- Factorization";			
  		fts:=Factorization(PolynomialRing(L)!pol2);
  		ker1:=fts[1][1];//select on kernel
  		
  		//"----5---IsogenyFromKernel";	
			F1_1,map:=IsogenyFromKernel(Eext,ker1);			
			pt:=Eext![0,0,1];
			imgpt:=map(pt);	
			//error"stop";	
		
    		//"--------------------- 6-1 ---------------------------";
    		//"----6---TateNormalForm";   	
    		TateF1:=TateNormalForm(F1_1,imgpt,l);
    		//"Tate normal form:",TateF1;
		//"--------------------- 7 ---------------------------";
		a1,a2,a3,a4,a6:=Explode(aInvariants(TateF1));
		
		//Y^2+a1*xy+a3*Y=X^3+a2*X^2+a4*X+a6
		
		if (a4 ne 0) or (a6 ne 0) or (a3 ne a2) then 
			error"the result elliptic curve is not in needed form!";
		end if;
		

   		c:=1-a1;
   		b:=-a3;
   		r29:=b/c;
   		s29:=c/(r29-1);
   		X:=(s29-r29)/(r29*s29-2*r29+1);
   		Y:=(r29*s29-2*r29+1)/(s29^2-s29-r29+1);						
		if EvaluteX1(X,Y) eq false then error"fl!=0 904";end if;

			 
 	        tmp:=UnderPoint(<X,Y>);
       	        ix:=tmp[1];
       	        iy:=tmp[2];
       	        
       	              	          
       	        if Degree(Parent(ix)) ge Degree(Parent(iy))then
       	           FFixxiyy:=Parent(ix);
       	        else
       	            FFixxiyy:=Parent(iy);
       	        end if;
       	        
       	        //"parent(ix,iy)",FFixxiyy;

       	        dixx:=MinimalPolynomial(ix,FFXY);
       	        diyy:=MinimalPolynomial(iy,FFXY);
       	        
       	        if dixx ge diyy then
       	          FFixxiyy:=ext<FFXY | dixx>;
       	        else
       	          FFixxiyy:=ext<FFXY | diyy>;
       	        end if;
       	        
       	        //"exact parent(ix,iy)",FFixxiyy;       	          
       	        
       	        //"under point (ixx,iyy)",ixx,iyy;
       	        
       	        ddi:=Degree(FFixxiyy,FFXY);   
       	        if ddi ne 2 then error"degree 1 * degree 2, second root extension degree should be 2 ";end if;         	                     	                 	          
       	        tmpnum:=#FFXY;
       	         	      		
	        for ii:=0 to ddi-1 do
	              Append(~Rts,<ix^(tmpnum^ii),iy^(tmpnum^ii)>);	
	        end for;
	  	
	  		  					     	
	 else//f2=(X-alpha1)(X-alpha2)(X-alpha3)//11111
	  "factored completely";		  
	  //"---1---,Factorization";	
	  for i:=1 to 3 do
	  	
	  	kerpol:=ftsss[i][1];
	  	//"--2---IsogenyFromKernel";	
	     	F1_1,map:=IsogenyFromKernel(E,kerpol);			
		pt:=E![0,0,1];
		imgpt:=map(pt);	
		//error"stop";	
	     
       		//"--------------------- 6-1 ---------------------------";
       		//"---3---TateNormalForm";   	
       		TateF1:=TateNormalForm(F1_1,imgpt,l);
       		//"Tate normal form:",TateF1;
		//"--------------------- 7 ---------------------------";
		a1,a2,a3,a4,a6:=Explode(aInvariants(TateF1));
		   
		//Y^2+a1*xy+a3*Y=X^3+a2*X^2+a4*X+a6
		   
		if (a4 ne 0) or (a6 ne 0) or (a3 ne a2) then 
		   	error"the result elliptic curve is not in needed form!";
		 end if;	
	     

   		c:=1-a1;
   		b:=-a3;
   		r29:=b/c;
   		s29:=c/(r29-1);
   		X:=(s29-r29)/(r29*s29-2*r29+1);
   		Y:=(r29*s29-2*r29+1)/(s29^2-s29-r29+1);						
		if EvaluteX1(X,Y) eq false then error"fl!=0 964";end if;
			 
 	        tmp:=UnderPoint(<X,Y>);
       	        ix:=tmp[1];
       	        iy:=tmp[2];      	        
       	               	              	          
       	        if Degree(Parent(ix)) ge Degree(Parent(iy))then
       	           FFixxiyy:=Parent(ix);
       	        else
       	            FFixxiyy:=Parent(iy);
       	        end if;
       	        
       	        //"parent(ixx,iyy)",FFixxiyy;

       	        dixx:=MinimalPolynomial(ix,FFXY);
       	        diyy:=MinimalPolynomial(iy,FFXY);
       	        
       	        if dixx ge diyy then
       	          FFixxiyy:=ext<FFXY | dixx>;
       	        else
       	          FFixxiyy:=ext<FFXY | diyy>;
       	        end if;
       	        
       	        ddi:=Degree(FFixxiyy,FFXY);   
       	        if ddi ne 1 then 
       	        	//"degree 1 * degree 1 *degree 1, extension degree should be 1 except special case!!! ";
       	                 	                     	                 	          
       	        	tmpnum:=#FFXY;
       	         	      		
	        	for ii:=0 to ddi-1 do
	              		//check whether <ix^(tmpnum^ii),iy^(tmpnum^ii)> in Rts very special situation!!
	              		//T_2(P)=P1+P2+P3, pair-wise different?
	              		tfgg:=true;
	              		if #Rts ge 1 then	              		
	              			for iii:=1 to #Rts do
	              				if Rts[iii][1] eq ix^(tmpnum^ii) and Rts[iii][2] eq iy^(tmpnum^ii) then
	              					tfgg:=false;
	              					break;
	              				end if;
	              			end for;
	              		end if;
	                	
	              		if tfgg then
	              			Append(~Rts,<ix^(tmpnum^ii),iy^(tmpnum^ii)>);
	              		end if;		
	        	end for;
	        else
	        	//T_2(P)=P1+P2+P3, pair-wise different? no!	        
	        	Append(~Rts,<ix,iy>);  	
	  	end if;
	  	
	  	//"Rts=",Rts;
	  end for;	
		
	end if;//11111
		
end if;//000000		
						
	//add the all the conjugate set of point (degree of the place) 
        tmp:=<>;
        for jj:=1 to #Rts do
        	for ii:=0 to DgoFldplc1-1 do
        		cc:=<(Rts[jj][1])^(num^(ii)),(Rts[jj][2])^(num^(ii))>;	
        	 	 //"-----------";
        	  	Append(~tmp,cc);
        	  	//"+++++++++++";
        	end for;
        end for;
        //"tmp=", tmp;
        //error"stop";
        nxys:=#tmp;	//number of xy pairs	
        //"-------------------";
	      
	xys:=tmp;
	//"first xys",xys;
	//Type(xys);
	
	//"------ TqPlace 2----------",Cputime();	
	divori:=P-P;	
	while true do
	      //"xys",xys;
	      //"time in Polyofbc";
	      minpoly:=Polyofbc(xys[1],F);
		    		      		
		    for i:=0 to Degree(minpoly)-1 do
		    		      		  
		     	  if Tupinornot(<xys[1][1]^(num^i),xys[1][2]^(num^i)>,xys) eq false then 
		     	  	"i=",i,<xys[1][1]^(num^i),xys[1][2]^(num^i)>;
		     	  	error"the input pairs are not complete";
		     	  end if;
		     	
		    end for;
		    //"TqPlace 2 -2",Cputime();
		    ptset:=<>;
        	    for jj:=0 to Degree(minpoly)-1 do
        	        	Append(~ptset,<(xys[1][1])^(num^jj),(xys[1][2])^(num^jj)>);            		
        	    end for;
        	    //"====================";	
        	    //"ptset=",ptset;
        	    //"time in point set to place";      	
		    plc:=PointSetToPlace(FxFxyF,ptset);
		    eofplc:=0;
		    //"TqPlace 2 -4",Cputime();	
		    for kk:=1 to #xys do
		    		if xys[1] eq xys[kk] then 
		    			eofplc:=eofplc+1;
		    		end if;
		    end for;
		    //"eofplc=",eofplc;
		    //"~~~~~~~~~~~~~~~~~~";	      		
		    divori:=divori+eofplc*plc;
		    newxys:=<>;
		    //"TqPlace 2 -5",Cputime();  
		    for kk:=1 to #xys do
		    	  if Tupinornot(<xys[kk][1],xys[kk][2]>,ptset) eq false then
		    	    Append(~newxys,xys[kk]);
		    	  end if;	
		    end for;
		    //"TqPlace 2 -6",Cputime();			
		    xys:=newxys;
		    	
		    if #xys eq 0 then break;end if;			      
	end while;       
	      	      	      
        if Degree(divori) ne (q+1)*DgoFldplc1 then
        	"Degree(divori)=",Degree(divori);
        	"tmp", tmp;
        	"DgoFldplc1", DgoFldplc1;
        	 "q",q;
        	 
        	error"problem with your program TqPlace() 1132";
        end if;
        	
	return true,divori;
							
end 	function;
	
/////////////////////////////////////////////////////////////////////////////

function T2Divisor(FxFxyF,Cusps,Dvr,p_q_l,Horbits)
//{T2(Dvr),Dvr=[Dtilde,O,rdg]}	
 
	O:=Divisor( Cusps[1] );
		
	noncusppart:=1*Dvr[1];
	
	cuspspart:=Dvr[3]*Dvr[2];
						
	supp1,exps1:=Support(noncusppart);
	//"Dvr supp1",Dvr,supp1;
	
  //"time in support";
  Dvr1:=O-O;
  		
  for i:=1 to #supp1 do
  	//"T2Divisor i,e degree",i,exps1[i],Degree(supp1[i]);
  	 tf:=true;
  	 if supp1[i] in Cusps then 
  	 	//"becarefull!! divisor supp1[i] in Cusps 1235";
  	 	cuspspart:=cuspspart+exps1[i]*supp1[i];  	 	 
  	 else  	 
  	 	tf,QQ:=T2Place(FxFxyF,p_q_l,supp1[i]);
  	 	//"time in one T2Place";
  		if tf eq false then
  			"try another random divisor T2Place return false 1199";
  			return false,<0,0,0>;   		
  		//break;
  		end if;  		  	 	
  	 	Dvr1:=Dvr1+exps1[i]*(QQ);
  	 end if;
  	 	

  	//"degree(QQ)=",Degree(QQ);			  	 		
  end for;
  
  Dvr2:=TqCusp(Cusps,cuspspart,2,p_q_l[3],Horbits);		
  //"time used in TqCusp";
  TqDvr:=Dvr1+Dvr2;
    		  	    	
  Dtilde,rdg,Advr,aele:=Reduction(TqDvr, O);
  
  //"Dtilde",Support(Dtilde);
  "reduction degree",rdg;
  //"time in one reduction";
  // check closed
	 
  if Degree(TqDvr)	ne 0 then error"T2Divisor(divosor) not degre 0";end if;
   
  return true,<Dtilde,O,rdg>; 
   
end 	function;

/////////////////////////////////////////////////////////////////////////////

function BqTqDvr(FxFxyF,Bq,Cusps,Dvr,p_q_l,Horbits)
/*
{ input a divisor given as Q-g*O,compute (Tq^d+...+a0)(Q-g*O),where T_q^d+...+a0 is the polynomial Bq 
	output is a diviosr given as D-g*O}
*/
  	
  O:=Divisor(Cusps[1]);//arranged as 1,1/2,...,1/n,n=(l-1)/2	
  						  
  nd:=Degree(Bq);
  
  SaveTqDvr:=<Dvr>;
  
  a0:=Integers()!Coefficient(Bq,0);
  	
  FinalDvr:=a0*(Dvr[1]+Dvr[3]*Dvr[2]);
  
  "Bq",Bq;
  "degree(Bq)",nd;
  "compute Bq(Tq)(Dvr)";
  	
  for i:=1 to nd do
  	   	//"q,i",p_q_l[2],i;
       		tmpTqDvr:=SaveTqDvr[i];
       
       		if p_q_l[2] eq 2 then
  		 tf,tmp:=T2Divisor(FxFxyF,Cusps,tmpTqDvr,p_q_l,Horbits);
  		else
  		 error"we have not yet consider the operator of level=",p_q_l[2];
  		end if; 	
  		
  		if tf eq false then
  		    "try another random divisor T2Divisor return fasle";	
  		 	  break;
  		 end if;
  		 		  	   
  	   Append(~SaveTqDvr,tmp);
  	   
  	   ai:=Integers()!Coefficient(Bq,i);
  	   if ai ne 0 then
  	   	   FinalDvr:=FinalDvr+(ai)*(tmp[1]+tmp[3]*tmp[2]);
  	   	   	
  	   	   Dtilde,rdg,Advr,aele:=Reduction(FinalDvr, O);
  	   	   //"time in reduction i=";
  	   	   	
  	   	   FinalDvr:=Dtilde+rdg*O;	
  	   end if;
  	   //"finished q,i",p_q_l[2],i;
  end for;
  //"end of compute Bq(Tq)(Dvr)"; 	
  if tf eq false then return false,<0,0,0>;end if;
  	  	      
  return true,<Dtilde,O,rdg>;

end function;

/////////////////////////////////////////////////////////////////////////////////

function Ltorsionpoint(Mod_As,FxFxyF,Cusps,plegkidxphis,Horbits)
//{new method to produce a l-torsion point!}
    FunFldx:=FxFxyF[1];
    FunFldxy:=FxFxyF[2];
    F_pe:=FxFxyF[3];		 
    Org:=Cusps[1];	
    O:=Divisor(Org);
    		
    p:=plegkidxphis[1];
    l:=plegkidxphis[2];
    extdg:=plegkidxphis[3];
    gns:=plegkidxphis[4];
    k:=plegkidxphis[5];    			
    h_index:=plegkidxphis[6];
    phis:=plegkidxphis[7];
    				
    indexvl,NofAilist,HPolyList:=FactorsJHl(Mod_As,[p,l,extdg,h_index,phis]);
    "indexvl",indexvl;	
    "NofAilist",NofAilist;
    "HPolyList",HPolyList;	
    
    "generating a random divisor";
    nu_try:=0;
    	
    while true do//loop find l-torsion point
    		nu_try:=nu_try+1;
    		while true do           		   
    		      tf,P:=HasRandomPlace(FunFldxy, 1);//to be precisely 1 should be changed to the a number less or equal to the genus
    		      //"random place degree one P=",P;
    		      flag:=IsFinite(P);
    		            	
    		      if (tf eq true) and (flag eq true) and ((P in  Cusps) eq false) then
    		         break;
    		      end if;	
    		end while;
    		
    		dvr:=<P,O,-1>;
    		
    		//"check",IsPrincipal(NofAilist[1]*NofAilist[2]*(P-O));
    		
    		"construncting a ",l,"-torsion point start";
    		tfbqtqdvr:=true;
 
    		q:=phis;
    		for i:=1 to #HPolyList do
    			if i ne indexvl then
    				HpolAi:=HPolyList[i];	
    				tfbqtqdvr,tp:=BqTqDvr(<FunFldx,FunFldxy,F_pe>,HpolAi,Cusps,dvr,<p,q,l>,Horbits);
    				
    				if tfbqtqdvr eq false then 
    		        		"try a new random divisor,construncting l-torsion point BqTqDvr return false 310";
    		        		break;    		       	 	
    		    end if;
    		    
    		    dvr:=tp;		
					end if;	
    		end for;
    		
    		if tfbqtqdvr then break;end if;
    		if nu_try gt 10 then error"try 10 times still not find l-torsion why?! 327";end if;	
    end while;
    

		"construncting a ",l,"-torsion point end";
		
  NofAindex:=NofAilist[indexvl];
  vlofAi:=Valuation(NofAindex,l);
  "cardinality of #A_{f_l}(Fq) =",NofAindex;
  "valuation of #A_{f_l}(Fq) at l: ord_l(A_{f_l}(Fq)) =",vlofAi;
  if vlofAi lt 2 then error"vlofAi<2 352";end if;
  
  //if 	vlofAi lt 2 then error"nop!";end if;
  
  lvlofAi:=l^vlofAi;
  	
  N_l:=NofAindex div lvlofAi;
  //trivial divisoin	
  factorsofNl,partb:=TrialDivision(N_l,2^25);
  //factorsofNl;
  if #partb ge 1 then 		   
     n2:=partb[1];
     //"n2=",n2;
     ffss:=Factorization(n2:MPQSLimit:=0);
     //ffss;	
     for i:=1 to #ffss do
     	Append(~factorsofNl,ffss[i]);
     end for;
  end if;
  "factorization of #A_{f_l}(Fq)/l^e=",factorsofNl;
				
	 mulN1:=1;
	 mulN2:=1;	
	 FactsIndex1:=[];
	 FactsIndex2:=[];
	 				
   for i:=1 to #factorsofNl do//00
  	if (factorsofNl[i][1] ne l)  then//01
  			pp:=factorsofNl[i][1];
  			Append(~FactsIndex1,pp);
  			Append(~FactsIndex2,pp);	
  			c1:=(factorsofNl[i][2]+1) div 2;
  			Append(~FactsIndex1,c1);	
  			c2:=factorsofNl[i][2]-c1;
  			Append(~FactsIndex2,c2);		
  			mulN1:=mulN1*(pp^c1);
  			mulN2:=mulN2*(pp^c2);			
  	end if;	  	    
   end for;//00

  Dtilde:=dvr[1];
  Advr:=dvr[2];
  rdg:=dvr[3];		
     	   
   //new method
   for i:=1 to (#FactsIndex1 div 2) do
   	 "p,e",FactsIndex1[2*i-1],FactsIndex1[2*i];
   	 pp:=FactsIndex1[2*i-1];
   	 ee:=FactsIndex1[2*i];	
   	 /*	
   	 for j:=1 to FactsIndex1[2*i] do
   	 	  "j=",j;
   	 	  time Dtilde,rdg,Advr,aele:=Reduction(pp*(Dtilde+rdg*Advr), O);
   	 end for;
   	 */
   	 //changed by
   	 Dtilde,rdg,Advr,aele:=Reduction((pp^ee)*(Dtilde+rdg*Advr), O);	
   end for;
   	
  if  IsPrincipal( Dtilde+rdg*Advr ) then
  	error"it is a principal divisor! why 421";
  	return false,[0,0,0];
  end if;
  					
  tf:=IsPrincipal(lvlofAi*(Dtilde+rdg*Advr));
  //"time use in test l^e(dvr) is or not principal";
  if tf then 
     "sqrt(J1(Fq)) * l^e kill the divisor, nice!";	
  else  
  	 "sqrt(J1(Fq)) * l^e can not kill the divisor :(";

     for i:=1 to (#FactsIndex2 div 2) do
     	 "p,e",FactsIndex2[2*i-1],FactsIndex2[2*i];
     	 pp:=FactsIndex2[2*i-1];
     	 for j:=1 to FactsIndex2[2*i] do
     	 	  "j=",j;	
     	 	  time Dtilde,rdg,Advr,aele:=Reduction(pp*(Dtilde+rdg*Advr), O);		
     	 end for;	
     end for;  	
  end if;
   	
  if  IsPrincipal( Dtilde+rdg*Advr ) then
  	return false,[0,0,0];
  end if;		
	
	for i:=1 to vlofAi do//00
            
      if IsPrincipal((l^i)*(Dtilde+rdg*Advr))  then//01
         Dtilde,rdg,Advr,aele:=Reduction((l^(i-1))*(Dtilde+rdg*Advr), O);       	
         //"rdg=",rdg;	      
         break;
      end if;//01
      
      if i eq vlofAi then 
      	return false,[0,0,0];
      	//error "error occur please check";
      end if;
                               
   end for;//00 
                            
    return true,<Dtilde,O,rdg>;  			    	
end function;

//////////////////////////////////////////////////////////////////////

function OneEleOfVl(Mod_As,FxFxyF,Cusps,plegkidx,pisphis,Horbits)
//{compute a element of Jl(F_q)[l]}

    FunFldx:=FxFxyF[1];
    FunFldxy:=FxFxyF[2];
    F_pe:=FxFxyF[3];		 
    Org:=Cusps[1];	
    O:=Divisor(Org);		
    p:=plegkidx[1];
    l:=plegkidx[2];
    extdg:=plegkidx[3];
    gns:=plegkidx[4];
    k:=plegkidx[5];
    index:=plegkidx[6];
    			    	
    PP<t>:=PolynomialRing(GF(l));
   
    q:=pisphis[1];    	

    "primes generate the maximal ideal m_{k,l} of Hecke algebra (End(A_f)) as an ideal=<l,",q,">";		
    "------21---";
    //generating an l-torsion point 
    while true do
    	tf,Dvr:=Ltorsionpoint(Mod_As,FxFxyF,Cusps,[p,l,extdg,gns,k,index,pisphis[2]],Horbits);
    	if tf then break;end if;	 
    end while;
    "--------------27--";       
    fqx,Bq,Cq,eC:=AnBnCnen(Mod_As[#Mod_As],q,l,k);//V_k_l in the last one
    
    "action of Bq(Tn)";
    tfbqtqdvr,bqtqdvr:=BqTqDvr(<FunFldx,FunFldxy,F_pe>,Bq,Cusps,Dvr,<p,q,l>,Horbits);
    "end action of Bq(Tn)";
    
    if tfbqtqdvr eq false then
	//drop this prime some trouble encountered            							
        return false,<0,0,0>;             							
     end if;
     	
    //action of Cq(T2)=T2-tau(2) several times
    tmpdvr:=bqtqdvr;
    tnb:=1;
    while true do//00
          tfbqtqdvr,tmpdvr1:=BqTqDvr(<FunFldx,FunFldxy,F_pe>,Cq,Cusps,tmpdvr,<p,q,l>,Horbits);
          tnb:=tnb+1;	
          if tfbqtqdvr eq false then 
          		"try a new random divisor,BqTqDvr retrun false lin 47";
          		return false,[0,0,0];
          		break;
          end if;
          
          if 	(tmpdvr1[1]+tmpdvr1[3]*tmpdvr1[2]) eq (O-O) then          	   
          	   break;
          end if;
          	
          tmpdvr:=tmpdvr1;
          	
          if tnb ge eC then 
          	tfbqtqdvr,tmpdvr1:=BqTqDvr(<FunFldx,FunFldxy,F_pe>,fqx,Cusps,tmpdvr,<p,q,l>,Horbits);
          	tmpdvr1;	
          	error"fqx(dvr)!=0 why";
          end if;		
              			    		
     end while;//00    
     
     Dvr:=tmpdvr[1]+tmpdvr[3]*tmpdvr[2];     
     if IsPrincipal(Dvr) eq true then
     	   "It's a principal divisor useless, bad prime! in OneEleOfVl.m,p=",p;
     	   return false,[0,0,0];
         //error"Vl1 is a principal divisor";
     end if;
     if IsPrincipal(l*Dvr) eq false then
     	   "It's not a l-torsion divisor, error occur, bad prime! in OneEleOfVl.m p=",p;
     	   return false,[0,0,0];	
     	   //error"Vl1 is not of order l";
     end if;
     		      
     return true,tmpdvr;     
end function;

////////////////////////////////////////////////////////////////////////

function Frobp(FxFxyF,Cusps,pleg,Vl1)
//{compute the Frob_p(Vl1) to get a new base element}

  Fx:=FxFxyF[1];
  Fxy:=FxFxyF[2];
  F:=FxFxyF[3];
  N:=#F;
  p:=pleg[1];
  l:=pleg[2];
  e:=pleg[3];
  gns:=pleg[4];
  O:=1*Cusps[1];
  	
  NoCuspVl1:=Vl1[1];
  CuspVl1:=Vl1[3]*Vl1[2];	
  Vl1:=NoCuspVl1+CuspVl1;
  									
  supps,exps:=Support(NoCuspVl1);
  
  Dvr:=CuspVl1;//cups part invariant under the Frobenius action
  		
  for i:=1 to #supps do 
  	
  	if supps[i] in Cusps then
  		Dvr:=Dvr+exps[i]*supps[i];
  	else  			
  		dofplc:=Degree(supps[i]);
  		
  		tf,u,v:=PlaceToPoint(F,supps[i]);
  					
  		ptset:=<<u^p,v^p>>;
   		for ii:=1 to 	dofplc-1 do
    	 Append(~ptset,<(u^(N^ii))^p,(v^(N^ii))^p>);
    	end for;	
    	
    	sigmaP:=PointSetToPlace(FxFxyF,ptset); 	
    	Dvr:=Dvr+exps[i]*sigmaP;
  	end if;  				
  	
  end for;
  
  if Degree(Dvr) ne 0 then 
  	 error" Dvr is not of degree 0";
  end if;			
  
  Dtilde,rdg,Advr,aele:=Reduction(Dvr, O);
  
  if rdg ne -gns then 
  	"the divisor might be not unique (rdg!=-g), Bad prime! p=",p;
  	return false,<0,0,0>;
  end if;	
  	  	  	  	  	
  //check linearly independence	
  flag:=0;
  for i:=1 to l-1 do 
  	if IsPrincipal((Dtilde+rdg*Advr)-i*Vl1) then
  		flag:=1;		
  		break;
  	end if;	  	
  end for;
  //end of check
  //"Vl1=",Vl1;
  if flag eq 0 then
  	"yes Frob_p(Vl1) is a new base element";
  	return true , <Dtilde,Advr,rdg>;
  else
  	"Vl1 Vl2 does not form a base! bad prime can be fixed";
  	return false,<0,0,0>;
  end if;			

end function;

//////////////////////////////////////////////////////////////////////

function CoefAndMonsofRatMpol(f)
//{f=f1/f2, f1 and f2 Multivariate Polynomials return CoefficientsAndMonomials(f1) and CoefficientsAndMonomials(f2)}

f1:=Numerator(f);
f2:=Denominator(f);

a,b:=CoefficientsAndMonomials(f1);
c,d:=CoefficientsAndMonomials(f2);

return <a,b>,<c,d>;
end function;

///////////////////////////////////////////////////////////////////

function DvrtoXYPoits(F_pe,dvr,Qcusps,p_l_g)
//{Given a divisor dvr, compute the points (x,y)}
  p:=p_l_g[1];
  l:=p_l_g[2];
  Nu:=#F_pe;		
  Ps,Es:=Support(dvr);
  
  
  XYPoints:=<>;
             							
  for kk:=1 to #Ps do
     if Ps[kk] in Qcusps then//010
  	  	      	"becareful! cusps in reduciotn divisor!,bad prime! p",p;
  	  	      	return false,0; 		
  	  	      	break;	
      end if;                                       	                                       	            										
  end for;		
  
  //compute the points of the corresponding places	
  a_p:=F_pe!0;
  
  for kk:=1 to #Ps do//09
	dofplc:=Degree(Ps[kk]);
	    	
	tf,u,v:=PlaceToPoint(F_pe,Ps[kk]);
	if tf eq false then return false,0;end if;
	//"xy_d",dofplc;
	//"xy_u",ElementToSequence(u);
	//"xy_v",ElementToSequence(v);
        //if tf eq false then return false ,0;end if;
        
        for ll:=1 to Es[kk] do          
            	Append(~XYPoints,<dofplc,u,v>);//save one representative  <degree,x,y>          
        end for;
        
   end for;//09
      
       return true,XYPoints;                
end function;

/////////////////////////////////////////////////////////////////////////////////////////////

function DvrPointstoQbar(F_pe,Dvr)
//{Given a divisor dvr=<<d_1,x_1,y_1>,...,<d_k,x_k,y_k>>, sum d_i =g compute the map f(dvr)}
  
  a_p:=0;
  Nu:=#F_pe;
  
  for i:=1 to #Dvr do
        d_i:=Dvr[i][1];
    	u:=Dvr[i][2];
    	v:=Dvr[i][3];
				
       	minf:=u; 
       	
       	
       	tmp:=minf-minf;                            
        tmp2:=minf;		
        for nn:=1 to d_i  do
         	tmp2:=tmp2^Nu;
         		
         	tmp:=tmp+tmp2;	
        end for;
        tmp:=F_pe ! tmp;
        
        a_p:=a_p+tmp; 
  end for;
  		
      
  return a_p;                
end function;

//////////////////////////////////////////////////////////////////////////////////////

function SavePointSet(FxFxyF,Vl_base,p_l_g,Qcusps,computation_nr)
//{enumerate all the point corresponding to i*Vl1+j*Vl2}

		p:=p_l_g[1];
		l:=p_l_g[2];
		gns:=p_l_g[3];
		F_pe<w>:=FxFxyF[3];
		Nu:=#F_pe;
       		
       		if #Qcusps ge 4 then //"number of Qcusps is more than 3";//use function from V_{k,l} -> F_q 
			ptA:=Qcusps[2];
       			ptB:=Qcusps[3];
			
			POL<T> := PolynomialRing(F_pe);								            			                        
	            
	            	O:=Divisor(Qcusps[1]);
	            	            			 	  		 		             	 						
	           	E1:=Vl_base[1];
	           	E2:=Vl_base[2]; 		
	           
	           	"F_pe",F_pe;			                  	 		
	           	
	           	SE1:=[];// saving 1*E1, 2*E1,... (l-1)*E1
	           	SE2:=[];// saving 1*E2, 2*E2,... (l-1)*E2
	           	           	
	           	SEij:=<>;	//saving (i*Ei+j*E2) i=0,1,...,l-1;j=0,1,...,l-1;
	           	//i=1, <(i-1)*Ei+(j-1)*E2,...>
	           	//<0, E2,    2*E2,...,   (l-1)*E2>	
	           	//<E1,E1+E2,...,      E1+(l-1)*E2>
	           	//......	
	           	//value1:=<>;
	           	//value2:=<>;
	           	//value12:=<>;
	           	E1_line:=<>;						
	           	//compute E1,2*E1,...,(l-1)*E1;E2 2*E2,...,(l-1)*E2 save them to reduce the time
	           	Dvr:=O-O;
	           	
	           	New_Points:=[];
	           	
	           	pt_line:=[];
	           	for ii:=1 to l-1 do
	           		   "ii",ii;
	           		   Dtilde,rdg,Advr,aele:=Reduction(Dvr+E1, O);
	           		   if rdg ne -gns then
	           		   	"i E1=",ii;
	           		   	"Dtilde",Dtilde; 
	           		   	"rdg=",rdg;
	           		   	"gns=",gns;
	           		   	"bad prime! p=",p;
	           		   	return false; 
	           		   	//error"reduction divisor has degree less than genus,which is bad!";
	           		   end if;           		  	
	           		   Dvr:=Dtilde+rdg*O;
	           		   
	           		   //compute the Riemann-Roch space begin
			   B_Dvr:=Basis(2*gns*Divisor(Qcusps[4])-Dtilde);
	           		   //B_Dvr:=Basis(2*gns*O-Dtilde);
	           		   //A= genx4:=x+1;geny4:=y;
	          
	          		   //B= genx5:=x+1; geny5:=y+1;
	          
	           		   f_A:=Evaluate(B_Dvr[1],ptA);//f_A;//EvaluateFld(B_Dvr[1],ptA);
	           		   f_B:=Evaluate(B_Dvr[1],ptB);//f_B;//EvaluateFld(B_Dvr[1],ptB);
	           		              		   
	           		   f_Adivf_B:=(f_A)/f_B;
	           		   //"f_Adivf_B=",f_Adivf_B;
	           		   Append(~pt_line,f_Adivf_B);
	           		   if #B_Dvr ne 1 then
	           		   	"dim L(DVR) >1 bad!";
	           		   	return false;
	           		   end if; 
	           		   //compute the Riemann-Roch space end           		              		   
	           		   //SE1; 		
	           		  Append(~SE1,Dtilde);
	           		  //SE1;
									//save the value and degree as well, save to file later
	           		  Append(~E1_line,<Degree(MinimalPolynomial(f_Adivf_B,F_pe)),f_Adivf_B>);
	          		                   		             		                  		               		                  		             		  
	           	end for;
	           	
	           	Append(~New_Points,pt_line);
	           	
	           	
	           	 E2_line:=<>;
	           	 pt_line:=[];        
	           	//value2:=<0>;           	           			
	           	Dvr:=O-O;
	           	for ii:=1 to l-1 do
	           		  "ii",ii;
	           		  //"--------2----------";
	           		   Dtilde,rdg,Advr,aele:=Reduction(Dvr+E2, O);
	           		  if rdg ne -gns then
	           		  	"i E1=",ii;
	           		  	"Dtilde",Dtilde; 
	           		  	"rdg=",rdg;
	           		  	"gns=",gns;
	           		  	"bad prime! p=",p;
	           		  	return false; 
	           		  	//error"reduction divisor has degree less than genus,which is bad!";
	           		  end if;           		  	
	           		  Dvr:=Dtilde+rdg*O;
	           		  
	           		   //compute the Riemann-Roch space begin
	           		   B_Dvr:=Basis(2*gns*Divisor(Qcusps[4])-Dtilde);
	           		   //A= genx4:=x+1;geny4:=y;
	          
	          		   //B= genx5:=x+1; geny5:=y+1;
	          
	           		   f_A:=Evaluate(B_Dvr[1],ptA);//EvaluateFld(B_Dvr[1],ptA);
	           		   f_B:=Evaluate(B_Dvr[1],ptB);//EvaluateFld(B_Dvr[1],ptB);
	            		              		   
	           		   f_Adivf_B:=(f_A)/f_B;
	           		   //"f_Adivf_B=",f_Adivf_B;
	           		    Append(~pt_line,f_Adivf_B);
	           		    if #B_Dvr ne 1 then
	           		   	"dim L(DVR) >1 bad!";
	           		   	return false;
	           		   end if; 
	           		   //compute the Riemann-Roch space end           		  
									
									//SE2; 		
	           		  Append(~SE2,Dtilde);
	           		  
	           		  
	           		  Append(~E2_line,<Degree(MinimalPolynomial(f_Adivf_B,F_pe)),f_Adivf_B>);
	
	           	end for;
	           	Append(~New_Points,pt_line);           	
	 		//Append(~value12,value2);// the first line of value12
	 		E1_jE2_lines:=<>;
	 		
	 						
			for jj:=1 to l-1 do	//00000
			//construct the line <ii*E1,ii*E1+E2,...,ii*E1+(l-1)*E2>
				tmplsit:=<>; 
				pt_line:=[];					             		  
	      		for ii:=1 to l-1 do	//00001
	        		"ii*(E1+jj*E2)=",ii,jj;                						
				Eij:=SE1[ii]-gns*O + SE2[jj*ii mod l]-gns*O;
	        		Dtilde,rdg,Advr,aele:=Reduction(Eij, O); 
	        		if rdg ne -gns then
	        			  "Eij=",Eij;
	     		      		  "Dtilde",Dtilde;
	        			  "rdg=",rdg;
	     		 		  "gns=",gns;
	     		 		  "bad prime! p=",p;
	     		 		  return false;                 		  
	        		end if;
	        		//compute the Riemann-Roch space begin
	           		B_Dvr:=Basis(2*gns*Divisor(Qcusps[4])-Dtilde);
	        		//B_Dvr[1];
	        		//A= genx4:=x+1;geny4:=y;
	        		
	        		//B= genx5:=x+1; geny5:=y+1;
	        		
	        		f_A:=Evaluate(B_Dvr[1],ptA);//EvaluateFld(B_Dvr[1],ptA);
	        		f_B:=Evaluate(B_Dvr[1],ptB);//EvaluateFld(B_Dvr[1],ptB);
	     			   
	        		f_Adivf_B:=(f_A)/f_B;
	        		//"f_Adivf_B=",f_Adivf_B;           		   
	        		Append(~pt_line,f_Adivf_B);
	        		if #B_Dvr ne 1 then
	        			"dim L(DVR) >1 bad!";
	        			return false;
	        		end if; 
	        		//compute the Riemann-Roch space end
	        		                		                		                	
	        		 Append(~tmplsit,<Degree(MinimalPolynomial(f_Adivf_B,F_pe)),f_Adivf_B>);           		                   		        
	                        		            		                   		                        		                	
	      		end for;//00001
	      		Append(~New_Points,pt_line);   
	          	Append(~E1_jE2_lines,tmplsit);
	      
	       		end for;//00000     							 
	 	        "computing the point sets finished";
       			
       		else //"number of cusps less than three use function on X_H(l)";
			POL<T> := PolynomialRing(F_pe);								            			                        
                	
            		O:=Divisor(Qcusps[1]);
            		            			 	  		 		             	 						
           		E1:=Vl_base[1];
           		E2:=Vl_base[2]; 		
                	
           		"F_pe",F_pe;			                  	 		
           		
           		SE1:=[];// saving 1*E1, 2*E1,... (l-1)*E1
           		SE2:=[];// saving 1*E2, 2*E2,... (l-1)*E2
           		           	
           		SEij:=<>;	//saving (i*Ei+j*E2) i=0,1,...,l-1;j=0,1,...,l-1;
           		//i=1, <(i-1)*Ei+(j-1)*E2,...>
           		//<0, E2,    2*E2,...,   (l-1)*E2>	
           		//<E1,E1+E2,...,      E1+(l-1)*E2>
           		//......	
           		//value1:=<>;
           		//value2:=<>;
           		//value12:=<>;
           		E1_line:=<>;						
           		//compute E1,2*E1,...,(l-1)*E1;E2 2*E2,...,(l-1)*E2 save them to reduce the time
           		Dvr:=O-O;
           		
           		New_Points:=[];
           		
           		pt_line:=[];
           		for ii:=1 to l-1 do
           			   "ii",ii;
           			   Dtilde,rdg,Advr,aele:=Reduction(Dvr+E1, O);
           			   if rdg ne -gns then
           			   	"i E1=",ii;
           			   	"Dtilde",Dtilde; 
           			   	"rdg=",rdg;
           			   	"gns=",gns;
           			   	"bad prime! p=",p;
           			   	return false; 
           			   	//error"reduction divisor has degree less than genus,which is bad!";
           			   end if;           		  	
           			   Dvr:=Dtilde+rdg*O;
           			   
           			   tf,xydvr:=DvrtoXYPoits(F_pe,Dtilde,Qcusps,p_l_g);
           			   if tf eq false then return false; end if;
           			   f_Adivf_B:=DvrPointstoQbar(F_pe,xydvr);
           			   Append(~pt_line,f_Adivf_B);
           			   //SE1; 		
           			  Append(~SE1,Dtilde);
           			  //SE1;
									//save the value and degree as well, save to file later
           			  Append(~E1_line,<Degree(MinimalPolynomial(f_Adivf_B,F_pe)),f_Adivf_B>);
          			                   		             		                  		               		                  		             		  
           		end for;
           		
           		Append(~New_Points,pt_line);
           		
           		
           		 E2_line:=<>;
           		 pt_line:=[];        
           		//value2:=<0>;           	           			
           		Dvr:=O-O;
           		for ii:=1 to l-1 do
           			  "ii",ii;
           			  //"--------2----------";
           			   Dtilde,rdg,Advr,aele:=Reduction(Dvr+E2, O);
           			  if rdg ne -gns then
           			  	"i E1=",ii;
           			  	"Dtilde",Dtilde; 
           			  	"rdg=",rdg;
           			  	"gns=",gns;
           			  	"bad prime! p=",p;
           			  	return false; 
           			  	//error"reduction divisor has degree less than genus,which is bad!";
           			  end if;           		  	
           			  Dvr:=Dtilde+rdg*O;
           			  
           			   tf,xydvr:=DvrtoXYPoits(F_pe,Dtilde,Qcusps,p_l_g);
           			   if tf eq false then return false; end if;
           			   f_Adivf_B:=DvrPointstoQbar(F_pe,xydvr);           		  
				   Append(~pt_line,f_Adivf_B);					
									//SE2; 		
           			  Append(~SE2,Dtilde);
           			  
           			  
           			  Append(~E2_line,<Degree(MinimalPolynomial(f_Adivf_B,F_pe)),f_Adivf_B>);
                	
           		end for;
           		Append(~New_Points,pt_line);           	
 			//Append(~value12,value2);// the first line of value12
 			E1_jE2_lines:=<>;
 			
 							
			for jj:=1 to l-1 do	//00000
			//construct the line <ii*E1,ii*E1+E2,...,ii*E1+(l-1)*E2>
				tmplsit:=<>; 
				pt_line:=[];					             		  
      			for ii:=1 to l-1 do	//00001
        			"ii*(E1+jj*E2)=",ii,jj;                						
				Eij:=SE1[ii]-gns*O + SE2[jj*ii mod l]-gns*O;
        			Dtilde,rdg,Advr,aele:=Reduction(Eij, O); 
        			if rdg ne -gns then
        				  "Eij=",Eij;
     			       		   "Dtilde",Dtilde;
        				  "rdg=",rdg;
     			 		  "gns=",gns;
     			 		  "bad prime! p=",p;
     			 		  return false;                 		  
        			end if;
        			        		
        			tf,xydvr:=DvrtoXYPoits(F_pe,Dtilde,Qcusps,p_l_g);
        			if tf eq false then return false; end if;
        			f_Adivf_B:=DvrPointstoQbar(F_pe,xydvr);
        			Append(~pt_line,f_Adivf_B);                		                		                	
        			Append(~tmplsit,<Degree(MinimalPolynomial(f_Adivf_B,F_pe)),f_Adivf_B>);           		                   		        
                	        		            		                   		                        		                	
      			end for;//00001
      			Append(~New_Points,pt_line);   
          		Append(~E1_jE2_lines,tmplsit);
                	
       			end for;//00000     							 
 	        	"computing the point sets finished";       		
       		end if;

		///////////////////////////////////////////////Save New_Points[] begin
		projname:="New_Points.dat";
    		projnamefilept1:=Open(projname,"a+");
		for i:=1 to l+1 do
			for j:= 1 to l-1 do
				fprintf projnamefilept1,"%o\n",New_Points[i][j];
			end for;
		end for;
		delete projnamefilept1;
		/////////////////////////////////////////////////Save New_Points[] end
       		       			

				
		//projective polynomial
    		projname:="proj_poly" cat IntegerToString(l) cat "_cpu" cat IntegerToString(computation_nr[1]) cat".dat";
    		projnamefilept1:=Open(projname,"a+");
		
		RR<x>:=PolynomialRing(F_pe);
		ZZ<t>:=PolynomialRing(Integers());
		Proj_f:=RR!1;
		for i:=1 to l+1 do
			tmp:=0;
			for j:=1 to l-1 do
				tmp:=tmp+New_Points[i][j];
			end for;
			Proj_f:=Proj_f*(x-tmp);
		end for;
		Proj_f:=ZZ!Proj_f;
           	fprintf projnamefilept1,"%o\n",p;
      		for i:=0 to Degree(Proj_f) do
      		         ai:=IntegerRing()!Coefficient(Proj_f,i);
      		         fprintf projnamefilept1,"%o\n",ai;	
      		end for;
      		delete projnamefilept1;
      		
      				
		//entire polynomial
		faitfulname:="fait_poly" cat IntegerToString(l) cat "_cpu" cat IntegerToString(computation_nr[1]) cat".dat";
		faitfulnamefilept2:=Open(faitfulname,"a+");
		Entire_f:=RR!1;
		////////////////////////////////////////////////////////////////////////Mascot's trick begin
		EvenOrd:=Valuation(l-1,2);
		EvenPart:=2^EvenOrd;
		OddPart:=Integers()!((l-1)/EvenPart);
		FF_l:=FiniteField(l);
		base:=Root(FF_l!(-1),2^(EvenOrd-1));
		for i:=1 to l+1 do
			for jjj:=0 to EvenPart-1 do
				tmp:=0;
				for j:=1 to l-1 do
					if Log(base,FF_l!(j^OddPart)) eq jjj then tmp:=tmp+New_Points[i][j];end if;
				end for;
				Entire_f:=Entire_f*(x-tmp);
			end for;
		end for;
		////////////////////////////////////////////////////////////////////////Mascot'strick end

		Entire_f:=ZZ!Entire_f;
           	fprintf faitfulnamefilept2,"%o\n",p;
      		for i:=0 to Degree(Entire_f) do
      		         ai:=IntegerRing()!Coefficient(Entire_f,i);
      		         fprintf faitfulnamefilept2,"%o\n",ai;	
      		end for;    
    		delete faitfulnamefilept2;
    		
		
		// print to file
		Nameoffile:="Vlmodps_cpu_"cat IntegerToString(computation_nr[1]) cat".dat";
    		filewrite:=Open(Nameoffile,"a+");
		//print Fp-->F_pe
		
		F_p:=GF(p);
		g_tor:=Generator(F_pe,F_p);
		poly_g_tor:=MinimalPolynomial(g_tor,F_p);
		se_qpoly_g_tor:=ElementToSequence(poly_g_tor);
		if #se_qpoly_g_tor ne Degree(F_pe)+1 then
			error"extension degree unexpected! ",#se_qpoly_g_tor,Degree(F_pe)+1;
		end if;
						
		fprintf filewrite, "%o %o ", p, Degree(F_pe);
		
		for k:=1 to #se_qpoly_g_tor do
			fprintf filewrite,"%o ",se_qpoly_g_tor[k];
		end for;
    		fprintf filewrite,"\n";
    		//		
		
		projlines:=<E1_line,E2_line>;
		for i:=1 to l-1 do 
			Append(~projlines,E1_jE2_lines[i]);
		end for;
		//alllines
		for i:=1 to l+1 do//001
		    E1_jE2_oneline:=projlines[i];
		    	
		    for ii:=1 to #E1_jE2_oneline do//002
		    	  dvr_ii:=E1_jE2_oneline[ii];
		    	  text_n:=0;
		    
				    dj:=dvr_ii[1];//degree of the value
				    vj:=dvr_ii[2];//value
				    
				    text_n:=text_n+dj;
				    FFF:=ext<F_pe|dj>;
				    vj:=FFF!vj;
				    				
				    fprintf filewrite,"%o ",dj;
				    
				    //-----v-----//
				    g_tor:=Generator(FFF,F_pe);
				    poly_g_tor:=MinimalPolynomial(g_tor,F_pe);				
				    
				    //recording the polynomial
				    se_qpoly_g_tor:=ElementToSequence(poly_g_tor);
				    
				    if #se_qpoly_g_tor ne dj+1 then
				        error"extension degree unexpected! ",#se_qpoly_g_tor,dj+1;
				    end if;
				    for k:=1 to #se_qpoly_g_tor do
				      tmp:=se_qpoly_g_tor[k];//in F_pe
				    	seqtmp:=ElementToSequence(tmp,F_p);
				    	if #seqtmp ne Degree(F_pe) then 
				    		error"unexpected degree seqtmp,Degree(F_pe)",seqtmp,Degree(F_pe);
				    	end if;
				    	
				    	for kk:=1 to #seqtmp do
				    		fprintf filewrite,"%o ",seqtmp[kk];
				    	end for;
				    	
				    end for;
				
				    //recoring the element seq				
				    seqvj:=ElementToSequence(vj,F_pe);
				    for k:=1 to #seqvj do
				    	tmp:=seqvj[k];//in F_pe
				    	seqtmp:=ElementToSequence(tmp,F_p);
				    	if #seqtmp ne Degree(F_pe) then 
				    		error"unexpected degree seqtmp,Degree(F_pe)",seqtmp,Degree(F_pe);
				    	end if;
				    	
				    	for kk:=1 to #seqtmp do
				    		fprintf filewrite,"%o ",seqtmp[kk];
				    	end for;
				    end for;
				     													         	
		    end for;//002
		    fprintf filewrite,"\n";
		end for;//001				
		delete filewrite;
		
		 		
		return true;		
end function;

/////////////////////////////////////////////////////////////////////////////////////////

function Jacl(As_p_e_k_l_index,pisphis,computation_nr,Horbits)
//{ compute the case (p,l)}
	Mod_As:=As_p_e_k_l_index[1];
	p:=As_p_e_k_l_index[2];
	extdg:=As_p_e_k_l_index[3];
	weight_k:=As_p_e_k_l_index[4];
	l:=As_p_e_k_l_index[5];
	index:=As_p_e_k_l_index[6];
	
	gns:=&+[Dimension(Mod_As[i]):i in [1..#Mod_As]];
	"p,e,weight,module,gns",p,extdg,weight_k,l,gns;
			 	       	       	
        F_pe<w>:=GF(p,extdg);//definition of Vl,so we consider J1l(F_p^extdg)
        
        FunFldx<x>:=FunctionField(F_pe);
        R<y> := PolynomialRing(FunFldx);
        
        tmp1,tmp2:=CoefficientsAndMonomials(XHldata()[1][1]);

	nx:=0;
	
	for i:=1 to #tmp1 do
		nx:=nx+tmp1[i]*x^(Degree(tmp2[i],Parent(tmp2[i]).1))*y^(Degree(tmp2[i],Parent(tmp2[i]).2));
	end for;
	
        XHl:=nx;
        //XHl;
        	
 	FunFldxy<y>:=FunctionField(XHl);
 	
	Css:=XHldata()[1][4];
        Qcusps:=[];
        
        //FunFldxy;        
        //Genus(FunFldxy);

        for i:=1 to #Css do
        
        
        	tmp1,tmp2:=CoefAndMonsofRatMpol(Css[i][1]);
        	        			
		nx:=0;
		
		for i:=1 to #tmp1[1] do
			nx:=nx+tmp1[1][i]*x^(Degree(tmp1[2][i],Parent(tmp1[2][i]).1))*y^(Degree(tmp1[2][i],Parent(tmp1[2][i]).2));
		end for;
		
		dx:=0;
		
		for i:=1 to #tmp2[1] do
			dx:=dx+tmp2[1][i]*x^(Degree(tmp2[2][i],Parent(tmp2[2][i]).1))*y^(Degree(tmp2[2][i],Parent(tmp2[2][i]).2));
		end for;
		gx:=nx/dx;
		//gx;
		
        	tmp1,tmp2:=CoefAndMonsofRatMpol(Css[i][2]);
        	       			
		nx:=0;
		
		for i:=1 to #tmp1[1] do
			nx:=nx+tmp1[1][i]*x^(Degree(tmp1[2][i],Parent(tmp1[2][i]).1))*y^(Degree(tmp1[2][i],Parent(tmp1[2][i]).2));
		end for;
		
		dx:=0;
		
		for i:=1 to #tmp2[1] do
			dx:=dx+tmp2[1][i]*x^(Degree(tmp2[2][i],Parent(tmp2[2][i]).1))*y^(Degree(tmp2[2][i],Parent(tmp2[2][i]).2));
		end for;
		gy:=nx/dx;
		//gy;		
	        	        	
        	P:=CommonZeros(FunFldxy,[gx,gy])[1];
        	
        	Append(~Qcusps,P);
        end for;
                     									        
        for i:=1 to #Qcusps do
        	 for j:=i+1 to #Qcusps do
        	 	if Degree(Qcusps[i]) ne 1 then 
        	 		
        	 		Qcusps[i];
        	 		error"problem with cusps";
        	 	end if;
        	 	if Qcusps[i] eq Qcusps[j] then 
        	 		
        	 		Qcusps[i];
        	 		Qcusps[j];
        	 		error"problem with cusps";
        	 	end if;
        	 end for;	
        end for;	
        //"rational cusps",Qcusps;
                		 
        Org:=Qcusps[1];	
  	O:=Divisor(Org);                	
		   					   		   	       
      "searching a base for Jacobian of modular curve X1(l) over F_p^extdg"; 
      tfv1,Vl1:=OneEleOfVl(Mod_As,<FunFldx,FunFldxy,F_pe>,Qcusps,[p,l,extdg,gns,weight_k,index],pisphis,Horbits);
      name1:="goodprimesused_weight" cat IntegerToString(weight_k) cat"_module" cat IntegerToString(l) cat "cpu_"cat IntegerToString(computation_nr[1]) cat ".dat";
      name2:="badprimes_weight" cat IntegerToString(weight_k) cat"_module" cat IntegerToString(l) cat "cpu_"cat IntegerToString(computation_nr[1]) cat ".dat";
      	       
       if tfv1 eq false then
       		filept:=Open(name2,"a+");
          	"bad prime p=",p;          	
          	Puts(filept,IntegerToString(p));
          	Puts(filept,IntegerToString(extdg));
          	delete filept;          			
       end if; 
       
       if tfv1 eq true then 	//15      
            //use Frob_p(Vl1) to get a new base element of Vl;
            tfv2,Vl2:=Frobp(<FunFldx,FunFldxy,F_pe>,Qcusps,[p,l,extdg,gns,weight_k,index],Vl1);
            
            if tfv2 eq false then
            		filept:=Open(name2,"a+");
               	"bad prime p=",p;              
               	Puts(filept,IntegerToString(p));
               	Puts(filept,IntegerToString(extdg));
               	delete filept;          			
            end if;	     
             	 
            "end of searching a base for Jacobian of modular curve X1(l) over F_p^extdg"; 
            
            if tfv2 eq true then//13
                "computing the polynomial corresponding to Vl(begin)";
                E1:=Vl1[1]+Vl1[3]*Vl1[2];
                E2:=Vl2[1]+Vl2[3]*Vl2[2];	
                	
                //tf:=ComputePolys(<FunFldx,FunFldxy,F_pe>,[E1,E2],<p,l,gns>,Qcusps);
                tf:=SavePointSet(<FunFldx,FunFldxy,F_pe>,[E1,E2],<p,l,gns>,Qcusps,computation_nr);
                "computing the polynomial corresponding to Vl(end)";
                
                if tf eq false then 
               	    filept:=Open(name2,"a+");
               	   "bad prime p=",p;
               	   Puts(filept,IntegerToString(p));
               	   Puts(filept,IntegerToString(extdg));
               	   delete filept; 
               	else
		   filept:=Open(name1,"a+");              	   
               	   Puts(filept,IntegerToString(p));
               	   
               	   delete filept;               		              	
                end if;//primes which are bad!
                          
           end if;//13
       end if;    //15
       	
       return true;	       	
end  function;

/////////////////////////////////////////////////////////////////////////////////////

function qEisensteinSeries(k,nth,M)
/*
{

E_k(z)=1-(2*k/B_k)*(sum_(n=1)^\infty sigma_(k-1)(n)*q^n  )

return the first nth coefficients of E_k(z) mod M.

if M 0 then return the first nth coefficients of E_k(z).

}
*/

check:=false;

Bk:=BernoulliNumber(k);
ldc:=-2*k/Bk;

qexp:=[];
a0:=1/1;//coefficients may lie in rational field
RM:=Integers(M);

if M eq 0 then
	qexp:=[a0];
	for i:=1 to nth do
		ai:=ldc*DivisorSigma(k-1,i);
		Append(~qexp,ai);
	end for;
	
	//"qexp",qexp;
	//check begin
	if check then
	Ek:=EisensteinSeries(ModularForms(1, k));
	//"Ek",Ek[1];
	for i:=0 to nth do
		if Coefficient(Ek[1],i)/Coefficient(Ek[1],0) ne qexp[i+1] then
			Coefficient(Ek[1],i)/Coefficient(Ek[1],0);
			qexp[i+1];
			error"no!!";
		end if;
		
	end for;
	"function checked! good!";
	//check end
	end if;	
else
	qexp:=[RM!a0];
	for i:=1 to nth do
		ai:=RM!ldc*DivisorSigma(k-1,i);
		Append(~qexp,ai);
	end for;
	//check begin
	if check then
	Ek:=EisensteinSeries(ModularForms(1, k));
	for i:=0 to nth do
		if RM!(Coefficient(Ek[1],i)/Coefficient(Ek[1],0)) ne qexp[i+1] then
			error"no!!";
		end if;
		
	end for;
	"function checked! good!";
	//check end
	end if;	
end if;

return qexp;



end function;

/////////////////////////////////////////////////////////////////////////////////

function NumOfJHl(Mod_As,p,l,e,h_index)
/*
{input:reduction prime p ,level of modular curve l,extension degree e,
output:#J(F_p^e),genus	}
*/

ZZ:=IntegerRing();

k:=e;
		
R2<T,U>:=PolynomialRing(ZZ,2);
	
fs:=FrobeniusPolynomialAs(Mod_As,l,p,h_index);

fx:=fs[1];
for i:=2 to #fs do
	fx:=fx*fs[i];
end for;


PT:=R2!0;
	
for i:=0 to Degree(fx) do
	  PT:=PT+Coefficient(fx,i)*T^i;
end for;
PTk:= Resultant(PT, T^k-U,T);
NofJOne:=Evaluate(PTk,[1,1]);

"cardinality of JH(",l,",",h_index,")(Fq)=",NofJOne;

dimjh:=0;
for i:=1 to #Mod_As do
	dimjh:=dimjh+Dimension(Mod_As[i]);
end for;
return NofJOne,dimjh;
	
end function;

////////////////////////////////////////////////

function dPlace(FxFxyF,p_q_l,P,d)
//{<d>P}
	 Fx:=FxFxyF[1];
	 Fxy:=FxFxyF[2];
	 F:=FxFxyF[3];
				      		
	 p:=p_q_l[1];//character
	 q:=p_q_l[2];//T_q 
	 l:=p_q_l[3];//l-torsion
	 
	 num:=#F;
	 	
	 DgoFldplc1:=Degree(P);
	 		
	 tf,X,Y:=PlaceToPoint(F,P);
	 
	 if tf eq false then return false,0;end if;

	 if EvaluteXH(X,Y) eq false then 
	 	P;
	 	X;
	 	Y;	 	
	 	error"XHl!=0 line 389";
	 end if;	 	 	 
	 
	 time rootsxy:=AbovePoint(<X,Y>);//a point on Xone(31) above (u,v)
	 "time AbovePoint";

	 if tf eq false then return false,0;end if;
	 
	 X:=rootsxy[1];
	 Y:=rootsxy[2];	 
	 if EvaluteX1(X,Y) eq false then 
	 	error"fl !=0 line 419";
	 else
	 	//"yes X29 =0 line 423";
	 end if;	 	 
	 
	 u:=rootsxy[1];
	 v:=rootsxy[2];
	 	   	
	 r:=(u^2*v-u*v+v-1)/(u^2*v-u);
	 s:=(u*v-v+1)/(u*v);
	 c:=s*(r-1);
	 b:=r*c;		 		

   
   tf,E:=IsEllipticCurve([1-c,-b,-b,0,0]);
   
   if tf eq false then return false,0;end if;
   
   pt:=E![0,0,1];
   dpt:=d*pt;
   	
   //TateNormalForm(E::CrvEll,usdpt::PtEll,l::RngIntElt) -> CrvEll			
   TateF1:=TateNormalForm(E,dpt,l);
   a1,a2,a3,a4,a6:=Explode(aInvariants(TateF1));
	
   //Y^2+a1*xy+a3*Y=X^3+a2*X^2+a4*X+a6
	
   if (a4 ne 0) or (a6 ne 0) or (a3 ne a2) then 
		error"the result elliptic curve is not in needed form!";
   end if;
   //"-------1---------";			

   	c:=1-a1;
   	b:=-a3;
   	r41:=b/c;
   	s41:=c/(r41-1);
   	X:=(s41-r41)/(r41*s41-2*r41+1);
   	Y:=(r41*s41-2*r41+1)/(s41^2-s41-r41+1);
   if EvaluteX1(X,Y) eq false then error"fl!=0 480";end if;
    //"-------2---------";
 
 	tmp:=UnderPoint(<X,Y>);
       	ixx:=tmp[1];
       	iyy:=tmp[2];
       	 
       	 Rts:=<<ixx,iyy>>; 	 	
	 	
	//add the all the conjugate set of point (degree of the place) 
        tmp:=<>;
        for jj:=1 to #Rts do
        		for ii:=0 to DgoFldplc1-1 do
        		cc:=<(Rts[jj][1])^(num^(ii)),(Rts[jj][2])^(num^(ii))>;	
        	  //"-----------";
        	  Append(~tmp,cc);
        	  //"+++++++++++";
        		end for;
        end for;
        //"-------3---------";        

        nxys:=#tmp;	//number of xy pairs	
        //"-------------------";
	xys:=tmp;	      
	//"------ TqPlace 2----------",Cputime();	
	divori:=P-P;	
	while true do
	            //"xys",xys;
	            //"TqPlace 2 -1",Cputime();
	            
	            minpoly:=Polyofbc(xys[1],F);
		    //"---4----";		      		
		    for i:=0 to Degree(minpoly)-1 do
		    		      		  
		     	  if Tupinornot(<xys[1][1]^(num^i),xys[1][2]^(num^i)>,xys) eq false then 
		     	  	"i=",i,<xys[1][1]^(num^i),xys[1][2]^(num^i)>;
		     	  	error"the input pairs are not complete";
		     	  end if;
		     	
		    end for;
		    //"TqPlace 2 -2",Cputime();
		    ptset:=<>;
                    for jj:=0 to Degree(minpoly)-1 do
                     		//check check
                     		f1:=(xys[1][1])^(num^jj);//==X
                     		f2:=(xys[1][2])^(num^jj);//==Y
 
                 		if EvaluteXH(f1,f2) eq false then error"XHl!=0 531";end if;                                                                              
                    		//end check                   
                        	Append(~ptset,<(xys[1][1])^(num^jj),(xys[1][2])^(num^jj)>);            		
                    end for;
                    //"====================";	
                    //"ptset=",ptset;

                    //"time in point set to place";      	
		    plc:=PointSetToPlace(FxFxyF,ptset);
		    eofplc:=0;
		    //"TqPlace 2 -4",Cputime();	
		    for kk:=1 to #xys do
		    		if xys[1] eq xys[kk] then 
		    			eofplc:=eofplc+1;
		    		end if;
		    end for;
		    //"eofplc=",eofplc;
		    //"~~~~~~~~~~~~~~~~~~";	      		
		    divori:=divori+eofplc*plc;
		    newxys:=<>;
		    //"TqPlace 2 -5",Cputime();  
		    for kk:=1 to #xys do
		    	  if Tupinornot(<xys[kk][1],xys[kk][2]>,ptset) eq false then
		    	    Append(~newxys,xys[kk]);
		    	  end if;	
		    end for;
		    //"TqPlace 2 -6",Cputime();			
		    xys:=newxys;
		    	
		    if #xys eq 0 then break;end if;			      
	end while;       
	// "-------4---------";	      
	//"------ TqPlace 3----------",Cputime();
	      
	      
        if Degree(divori) ne DgoFldplc1 then
        	"Degree(divori)=",Degree(divori);
        	"tmp", tmp;
        	"DgoFldplc1", DgoFldplc1;
        	 "q",q;
        	 
        	error"problem with your program TqPlace() 582";
        end if;
        	
	return true,divori;	 	
	 	
end function;

////////////////////////////////////////////////

function FindCuspsCorr(Mod_As,k,l)
/*
{
given Q-rational cusps of X_H(l) represented by prime ideals of function field Q(X_H(l))
Q-rational cusps of X_H(l) can also represented by 1/1,...,1/((l-1) /2)
this function compute the correspondences between these two  representations
}
*/
h_index:=((l-1)) div GCD(l-1,k-2);

dmop:=Integers()!PrimitiveElement(GF(l));//diamond operators

H:=[];

d:=PrimitiveElement(GF(l))^h_index;

for i:=1 to l do
	di:=(Integers()!(GF(l)!d^i)) mod l;
	
	if di gt (l div 2) then di:=l-(di);end if;
	
	if di in H eq false then Append(~H,di);end if;
end for;

"H",H;

Horibts:=[];//ordered as [dmop^0*H,dmop^1*H,...,dmop^(h_index-1)*H]

for i:=0 to h_index-1 do
	Hi:=[];
	for j:=1 to #H do
		tmp:=dmop^i*H[j] mod l;
		if tmp gt (l div 2) then tmp:=l-(tmp);end if;
		Append(~Hi,tmp);
	end for;
	Append(~Horibts,Hi);
end for;

		
//=== begin finding a prime p such that l divides #JH(l)(F_q) ====

 p:=NextPrime(l+133);
 extdg:=2;

 while true do
    "p=",p;
     NuofJac,gns:=NumOfJHl(Mod_As,p,l,extdg,h_index);
     ord_l:=Valuation(NuofJac,l);	
     if ord_l ge 1 then break;end if;
     p:=NextPrime(p);		
 end while;	

"p",p;
//==== finished========================================//

// data of plane model of X1(19)
F_pe<w>:=GF(p,extdg);
FunFldx<x>:=FunctionField(F_pe);
Ringy<y>:=PolynomialRing(FunFldx);
tmp1,tmp2:=CoefficientsAndMonomials(XHldata()[1][1]);

nx:=0;

for i:=1 to #tmp1 do
	nx:=nx+tmp1[i]*x^(Degree(tmp2[i],Parent(tmp2[i]).1))*y^(Degree(tmp2[i],Parent(tmp2[i]).2));
end for;

XHl:=nx;
//XHl;
        
FunFldxy<y>:=FunctionField(XHl);

Css:=XHldata()[1][4];

Qcusps:=[];


for i:=1 to #Css do


	tmp1,tmp2:=CoefAndMonsofRatMpol(Css[i][1]);
	        			
	nx:=0;
	
	for i:=1 to #tmp1[1] do
		nx:=nx+tmp1[1][i]*x^(Degree(tmp1[2][i],Parent(tmp1[2][i]).1))*y^(Degree(tmp1[2][i],Parent(tmp1[2][i]).2));
	end for;
	
	dx:=0;
	
	for i:=1 to #tmp2[1] do
		dx:=dx+tmp2[1][i]*x^(Degree(tmp2[2][i],Parent(tmp2[2][i]).1))*y^(Degree(tmp2[2][i],Parent(tmp2[2][i]).2));
	end for;
	gx:=nx/dx;
	//gx;
	
	tmp1,tmp2:=CoefAndMonsofRatMpol(Css[i][2]);
	       			
	nx:=0;
	
	for i:=1 to #tmp1[1] do
		nx:=nx+tmp1[1][i]*x^(Degree(tmp1[2][i],Parent(tmp1[2][i]).1))*y^(Degree(tmp1[2][i],Parent(tmp1[2][i]).2));
	end for;
	
	dx:=0;
	
	for i:=1 to #tmp2[1] do
		dx:=dx+tmp2[1][i]*x^(Degree(tmp2[2][i],Parent(tmp2[2][i]).1))*y^(Degree(tmp2[2][i],Parent(tmp2[2][i]).2));
	end for;
	gy:=nx/dx;
	//gy;		
        	        	
	P:=CommonZeros(FunFldxy,[gx,gy])[1];
	
	Append(~Qcusps,P);
end for;
             									        
for i:=1 to #Qcusps do
	 for j:=i+1 to #Qcusps do
	 	if Degree(Qcusps[i]) ne 1 then 
	 		
	 		Qcusps[i];
	 		error"problem with cusps";
	 	end if;
	 	if Qcusps[i] eq Qcusps[j] then 
	 		
	 		Qcusps[i];
	 		Qcusps[j];
	 		error"problem with cusps";
	 	end if;
	 end for;	
end for; 
   		   	       	

"the action on cusps ";

" begin finding corresponding of the cusps";

//diamond operator <dmop> acting on  places

Order_num_cusp:=[1];
				
while true do//01
	j:=Order_num_cusp[#Order_num_cusp];
	"j=",j;
      	
	O:=Divisor(Qcusps[j]);      
                        
        for i:=1 to #Qcusps do //02
         	  "i=",i;
        	            	
                  dmopO:=Qcusps[i];//assume <d>O	      
                  
                  nuoftest:=0;//if the assumption pass m tests we claim we have the right answer
                  
                  flagofwhile:=0;
                 
                  m:=1;//number of tested		
                  
                  while nuoftest lt m do//00
                        //check the assumption
                        tf,P1:=HasRandomPlace(FunFldxy, gns);
                        	
                        if tf eq true then//1
                                //generates a torsion divisor
          	            	Dvr:=(NuofJac div l^ord_l)*P1-gns*(NuofJac div l^ord_l)*O;
          	            	tilde,rdg,Advr,aele:=Reduction(Dvr, O);
          	            	Dvr:=tilde+rdg*O;
          	            			
          	            	if IsPrincipal(Dvr)  then//0001    
                         		   //"it's a principal divisor useless";
           	            	else //0001
           	            		 
           	            	      for i:=1 to ord_l do//00
                                      
                                          if IsPrincipal((l^i)*Dvr)  then//01
                                             //"Dvr is of order ",l^i;
                                             Dtilde,rdg,Advr,aele:=Reduction((l^(i-1))*Dvr, O);
                                             //"reduction diviosr Dvr",Dtilde;
                                             //"degree of reduciotn divisor",rdg;                                         
                                             break;
                                          end if;//01
                                          
                                          if i eq ord_l then error " i eq ord_l error occur please check";end if;
                                                  
                                      end for;//00 compute the exact order of Dvr make it be a divisor of order l
                              
                                      Dvr:=Dtilde+rdg*O;
           	            		  
           	            	    if IsPrincipal(l*Dvr)  eq false then error"no!";end if;
           	            		  
           	            			supp, exps := Support(Dtilde);
           	            				
           	            			//"------- diamond operator acting on noncusp part --------------";
           	            			
           	            			Tqsupp:=O-O;
           	            			flagcusp:=0;		
           	            			for k:=1 to #supp do//02
           	            			      if (supp[k] in Qcusps) eq true then//03
          	      					   //"cusps in rdeuction divisor drop it";
                                                           flagcusp:=1;
                                                           break;				 
           	            			      else
           	            			      	   tf,dvr:=dPlace(<FunFldx,FunFldxy,F_pe>,<p,0,l>,supp[k],dmop);
           	            			      	   if tf eq false then 
           	            			      	   	flagcusp:=1;break;
           	            			      	   end if;
           	            			      	   //"---dajdoajdkajdo";		
           	            			      	   Tqsupp:=Tqsupp+exps[k]*(dvr);
           	            			      end if;//03
           	            			end for;//02
           	            			//"-------- 3 -------------";
           	            			
           	            			//compute the divisor using assumption
           	            			if flagcusp eq 0 then
           	            			     TqDvr:=Tqsupp+rdg*dmopO;
           	            			           
           	            		              if Degree(TqDvr) ne 0 then error"no!check the program";end if;
           	            		       	
           	            			      if IsPrincipal(l*TqDvr) then 
           	            			     	//"yes";
           	            			     	nuoftest:=nuoftest+1;
           	            			      else 
           	            			     	//"try another correspondence";
           	            			     	flagofwhile:=1;	
           	            			       end if;
           	            			 end if;  	
                       	            								
           	            	end if;//0001		
                        		
                        end if;//1
                        	
                        if flagofwhile eq 1 then 	
                        	break;
                        end if;
                        		
                  end while;//00
                  
                  if nuoftest gt m-1 then 
                  	//"you find a right correspondence!";
                  	"<",dmop,">:O",j,"->","O",i;                  	

                  	if (#Order_num_cusp lt h_index) and (i in Order_num_cusp) then
                  		error"i should not in Order_num_cusp in this loop";
                  	end if; 
                  	
                  	Append(~Order_num_cusp,i); 
                  	                 	            	            		                  	
                  	break;   
                  end if ;	
                  //end of check the assumption
            
          end for;//02
          
          if nuoftest eq 0 then error"no O_i such that <d>O_j->O_i why!!";end if;

	  if #Order_num_cusp gt h_index then
	  	if Order_num_cusp[1] ne Order_num_cusp[h_index+1] then
	  		error"Order_num_cusp";
	  	else
	  		break;	
	  	end if;
	  end if;
end while;//01

" end of finding correspondences";

ReOrderHorbits:=[];

for i:=1 to h_index do
	for j:=1 to h_index do
		if Order_num_cusp[j] eq i then
			ReOrderHorbits[i]:=Horibts[j];
			break;
		end if;
	end for;
	
end for;


"ReOrderHorbits",ReOrderHorbits;

"check the output using diamnond operators";

  m:=0;//number of tested		
  nu:=#Qcusps;
  while m lt 10 do//00
       m:=m+1;
       
       O:=Divisor(Qcusps[(m mod nu)+1]);
       
       "O",(m mod nu)+1;
       
        //check the assumption
        tf,P1:=HasRandomPlace(FunFldxy, gns);
        flagofwhile:=0;
        	
        if tf eq true then//1
                //generates a torsion divisor
        	//"begin";
            	Dvr:=(NuofJac div l^ord_l)*P1-gns*(NuofJac div l^ord_l)*O;
            	//Dvr:=(NuofJac div tor)*P1-5*(NuofJac div tor)*O;
            	//"time in big reduction ";
            	tilde,rdg,Advr,aele:=Reduction(Dvr, O);
            	Dvr:=tilde+rdg*O;
            			
            	if IsPrincipal(Dvr)  then//0001    
         		   //"it's a principal divisor useless";
            	else //0001
            		 
            	      for i:=1 to ord_l do//00
                      
                          if IsPrincipal((l^i)*Dvr)  then//01
                             //"Dvr is of order ",l^i;
                             Dtilde,rdg,Advr,aele:=Reduction((l^(i-1))*Dvr, O);
                          
                             //"reduction diviosr Dvr",Dtilde;
                             //"degree of reduciotn divisor",rdg;
                          
                             break;
                          end if;//01
                          
                          if i eq ord_l then error " i eq ord_l error occur please check";end if;
                                  
                      end for;//00 compute the exact order of Dvr make it be a divisor of order l
              
                      Dvr:=Dtilde+rdg*O;
            		  
            	    if IsPrincipal(l*Dvr)  eq false then error"no!";end if;
            		  
            			supp, exps := Support(Dtilde);
            				
            			//"------- diamond operator acting on noncusp part --------------";
            			
            			Tqsupp:=O-O;
            			flagcusp:=0;		
            			for k:=1 to #supp do//02
            			      if (supp[k] in Qcusps) eq true then//03
      					   //"cusps in rdeuction divisor drop it";
                                           flagcusp:=1;
                                           break;				 
            			      else

            			      	   tf,dvr:=dPlace(<FunFldx,FunFldxy,F_pe>,<p,0,l>,supp[k],dmop);
            			      	   if tf eq false then 
            			      	   	flagcusp:=1;break;
            			      	   end if;
            			      	   //"---dajdoajdkajdo";		
            			      	   Tqsupp:=Tqsupp+exps[k]*(dvr);
            			      end if;//03
            			end for;//02
            			//"-------- 3 -------------";
            			            			
            			if flagcusp eq 0 then
            			     TqDvr:=Tqsupp+rdg*diamondcusp(Qcusps,O,l,dmop,ReOrderHorbits);
            			           
            		              if Degree(TqDvr) ne 0 then 
            		              	
            		              	error"no!check the program";
            		              
            		              end if;
            		       	
            			      if IsPrincipal(l*TqDvr) then 
            			     	//"yes";
            			     	
            			      else 
            			     	error"no not l-torsion!!! why!!";
            			     	flagofwhile:=1;	
            			       end if;
            			 end if;  	
       	            								
            	end if;//0001		
        		
        end if;//1
        	
        if flagofwhile eq 1 then 	
        	break;
        end if;
        		
  end while;//00

"end of check the output using diamnond operators";


"check the output using Hecke  operator T2";

//check T_q 
  q:=2;
  m:=0;//number of tested		
  nu:=#Qcusps;
  while m lt 110 do//00
       m:=m+1;
       
       O:=Divisor(Qcusps[(m mod nu)+1]);
       
       "----------------O",(m mod nu)+1;
       
        //check the assumption
        tf,P1:=HasRandomPlace(FunFldxy, gns);
        flagofwhile:=0;
        	
        if tf eq true then//1
                //generates a torsion divisor
        	//"begin";
            	Dvr:=(NuofJac div l^ord_l)*P1-gns*(NuofJac div l^ord_l)*O;
            	//Dvr:=(NuofJac div tor)*P1-5*(NuofJac div tor)*O;
            	//"time in big reduction ";
            	tilde,rdg,Advr,aele:=Reduction(Dvr, O);
            	Dvr:=tilde+rdg*O;
            			
            	if IsPrincipal(Dvr)  then//0001    
         		   //"it's a principal divisor useless";
            	else //0001
            		 
            	      for i:=1 to ord_l do//00
                      
                          if IsPrincipal((l^i)*Dvr)  then//01
                             //"Dvr is of order ",l^i;
                             Dtilde,rdg,Advr,aele:=Reduction((l^(i-1))*Dvr, O);
                          
                             //"reduction diviosr Dvr",Dtilde;
                             //"degree of reduciotn divisor",rdg;
                          
                             break;
                          end if;//01
                          
                          if i eq ord_l then error " i eq ord_l error occur please check";end if;
                                  
                      end for;//00 compute the exact order of Dvr make it be a divisor of order l
              
                      Dvr:=Dtilde+rdg*O;
            		  
            	    if IsPrincipal(l*Dvr)  eq false then error"no!";end if;
            		  
            			supp, exps := Support(Dtilde);
            				
            			//"------- diamond operator acting on noncusp part --------------";
            			
            			Tqsupp:=O-O;
            			flagcusp:=0;		
            			for k:=1 to #supp do//02
            			      if (supp[k] in Qcusps) eq true then//03
      					   //"cusps in rdeuction divisor drop it";
                                           flagcusp:=1;
                                           break;				 
            			      else    
            			      	   tf,dvr:=T2Place(<FunFldx,FunFldxy,F_pe>,<p,q,l>,supp[k]);
            			      	   if tf eq false then 
            			      	   	flagcusp:=1;break;
            			      	   end if;
            			      	   //"---dajdoajdkajdo";		
            			      	   Tqsupp:=Tqsupp+exps[k]*(dvr);
            			      end if;//03
            			end for;//02
            			//"-------- 3 -------------";
            			
            			//compute the divisor using assumption
            			if flagcusp eq 0 then
            			     Tqcuspdvr:=TqCusp(Qcusps,O,q,l,ReOrderHorbits);//becareful!!
            			     //Tqcuspdvr;
            			     
            			     TqDvr:=Tqsupp+rdg*Tqcuspdvr;
            			           
            		              if Degree(TqDvr) ne 0 then error"no!check the program";end if;
            		       	
            			      if IsPrincipal(l*TqDvr) then 
            			     	"yes";
            			      else 
            			     	error"no not l-torsion!!! why!!";
            			     	flagofwhile:=1;	
            			       end if;
            			 end if;  	
       	            								
            	end if;//0001		
        		
        end if;//1
        	
        if flagofwhile eq 1 then 	
        	break;
        end if;
        		
  end while;//00

"end of check the output using Hecke  operator T2";


return ReOrderHorbits;

end function;

//////////////////////////////////////////////////////////////////////////////////

function Extdeg(p,taup,l,k)
/*
{compute the minimal extension degree of Ramanujan subspace V_l, 
	if the characteristic polynomial has equal eigen vales, return 100
	if extension degree > 7 return 100}
*/
 		
		//f:=x^2-a*x+b=x^2-tau_k(p)*x+p^(k-1)			
		
		a:=GF(l)!taup;
		b:=GF(l)!p^(k-1);	
		
		deta:=(a^2-4*b);
			
		if deta ne 0 then
			if a eq 0 and (-b) eq 1 then return 2;
			elif (-b + a^2) eq 0 and (-a*b) eq 1 then return 3;
			elif (-2*a*b + a^3) eq 0 and (b^2 - a^2*b) eq 1 then return 4;
			elif (b^2 - 3*a^2*b + a^4) eq 0 and (2*a*b^2 - a^3*b) eq 1 then return 5;
			elif (3*a*b^2 - 4*a^3*b + a^5) eq 0 and (- b^3 + 3*a^2*b^2 - a^4*b) eq 1 then return 6;
			else return 100;
			end if;
		else
			return 100;			
		end if;								
end function;
   	
/////////////////////////////////////////////////////////////////////////////////

function GeneratingCRTprimes()
/*
{==Deteming defining field of Ramanujan subspce V_(k,l)==

For k in [12,16,18,20,22,26] and l a prime number, generates all the small primes p such that

d_p:=min d>=1 : X^d=1 mod (X^2-tau_k(p)*X+p^(k-1),l )) in Extdg (Extdg contains those d_p allowed) 
}
*/

weight_k:=XHldata()[2][1];

l:=XHldata()[2][2];

Extdg:=[2,3,4,5];//  CRT prime p with d_p in  Extdg used

maximal_p:=10*10^5;//upper bound of CRT prime p (if too large, then memory lacking problem may arise during computing J_H(l)(F_q))

RM:=Integers(l);

P<x> := PowerSeriesRing(RM,maximal_p);
	
e4:=P!qEisensteinSeries(4,maximal_p,l);
e6:=P!qEisensteinSeries(6,maximal_p,l);
e8:=P!qEisensteinSeries(8,maximal_p,l);

Delta12:=(e4^3-e6^2);
a1:=1/Coefficient(Delta12,1);
Delta12:=a1*Delta12;

Delta16:=Delta12*e4;
a1:=1/Coefficient(Delta16,1);
Delta16:=a1*Delta16;

Delta18:=Delta12*e6;
a1:=1/Coefficient(Delta18,1);
Delta18:=a1*Delta18;

Delta20:=Delta12*e8;
a1:=1/Coefficient(Delta20,1);
Delta20:=a1*Delta20;

Delta22:=Delta12*e4*e6;
a1:=1/Coefficient(Delta22,1);
Delta22:=a1*Delta22;

Delta26:=Delta22*e4;
a1:=1/Coefficient(Delta26,1);

Delta26:=a1*Delta26;

pande:=[];
M:=1;

for eee in Extdg do
	p:=100;	
	while true do
		p:=NextPrime(p);
		if p gt maximal_p then break;end if;

		if weight_k eq 12 then
			ee:=Extdeg(p,Integers()!Coefficient(Delta12,p),l,weight_k);
		elif weight_k eq 16 then
			ee:=Extdeg(p,Integers()!Coefficient(Delta16,p),l,weight_k);
		elif weight_k eq 18 then
			ee:=Extdeg(p,Integers()!Coefficient(Delta18,p),l,weight_k);
		elif weight_k eq 20 then
			ee:=Extdeg(p,Integers()!Coefficient(Delta20,p),l,weight_k);
		elif weight_k eq 22 then
			ee:=Extdeg(p,Integers()!Coefficient(Delta22,p),l,weight_k);
		elif weight_k eq 26 then
			ee:=Extdeg(p,Integers()!Coefficient(Delta26,p),l,weight_k);
		else
			error"weight_k not in [12,16,18,20,22,26]",weight_k;
		end if;
		
		if (ee eq eee) then
			Append(~pande,p);
			Append(~pande,ee);
			M:=M*p;
		end if;			
	end while;	

end for;
"number of good primes",#pande div 2;
"Log(product of all p)",Log(M)/Log(10); 



name3:="allgoodprimes_weight"cat IntegerToString(weight_k) cat "_module" cat IntegerToString(l) cat ".dat";

"written to file:",name3;

filept1:=Open(name3,"w");

k:=1;
	
while true do
	p:=pande[2*k-1];
	e:=pande[2*k];	
	Puts(filept1,IntegerToString(p));
	Puts(filept1,IntegerToString(e));
	k:=k+1;
	
	if 2*k gt #pande then break;end if;	
end while;

delete filept1;			

return true;

end function;

////////////////////////////////////////////////////////////////////////////////

function ComputeRamanujanSubpaceModp(computation_nr)
//{computation_nr=[current task number, total tasks number(fixed during the computation)]}

weight_k:=XHldata()[2][1];

l:=XHldata()[2][2];

index:=(l-1) div GCD(l-1,weight_k-2);

Mod_As:=Afkl(weight_k,l);

"generating CRT primes begin";
//tf:=GeneratingCRTprimes();
"generating CRT primes end";

"find cusps correspondences begin";
//CorrOfCusps:=FindCuspsCorr(Mod_As,weight_k,l);
CorrOfCusps:=[[ 16, 10, 4, 18, 1 ],[ 14, 19, 17, 15, 6 ],[ 2, 9, 20, 8, 5 ],[ 12, 13, 3, 7, 11 ]];
"find cusps correspondences end";

//"replace me";

pis,phis:=PhiSet_and_Piset(Mod_As,weight_k,l);

curr_cpu_nmuber:=computation_nr[1];
number_of_cpus:=computation_nr[2];
"curr_cpu_nmuber",curr_cpu_nmuber;
"number_of_cpus",number_of_cpus;


"WARNING the number of total cpu used must be equal i.e. ";
"the second parameter of computation_nr must be equal";

"distribute the good primes to each cpu begin";
 name1:="allgoodprimes_weight"cat IntegerToString(weight_k) cat "_module" cat IntegerToString(l) cat ".dat";
 filept1:=Open(name1,"r");
 Primes:=[];
 while true do
        prm := Gets(filept1);
      	if IsEof(prm) then       	   
      	   break;
      	end if;         
        Primes:=Append( Primes,StringToInteger(prm) );        		  		        
 end while;
 delete filept1;
      
name2:="goodprimes_weight"cat IntegerToString(weight_k) cat "_module" cat IntegerToString(l) cat "cpu_"cat IntegerToString(curr_cpu_nmuber) cat ".dat";		
filept2:=Open(name2,"w");
k:=0;			
while true do
	p:=Primes[2*(number_of_cpus*k+curr_cpu_nmuber)-1];
	e:=Primes[2*(number_of_cpus*k+curr_cpu_nmuber)];	
	Puts(filept2,IntegerToString(p));
	Puts(filept2,IntegerToString(e));
	k:=k+1;
	if 2*(number_of_cpus*k+curr_cpu_nmuber) gt #Primes then break;end if;	
end while;
		
delete filept2;	

name3:="badprimes_weight" cat IntegerToString(weight_k) cat"_module" cat IntegerToString(l) cat "cpu_"cat IntegerToString(curr_cpu_nmuber) cat ".dat";	
filept3:=Open(name3,"a+");
delete filept3;

name4:="goodprimesused_weight" cat IntegerToString(weight_k) cat"_module" cat IntegerToString(l) cat "cpu_"cat IntegerToString(curr_cpu_nmuber) cat ".dat";	
filept4:=Open(name4,"a+");
delete filept4;

"distribute the good primes to each cpu end";

//the last modular abelian variety is the one where V_l lands inside
	
while true do //biggets loop
      Primes:=[];//primes used
      Badprimes:=[];//bad primes in the file
      eBadprimes:=[];
      name1:="goodprimesused_weight" cat IntegerToString(weight_k) cat"_module" cat IntegerToString(l) cat "cpu_"cat IntegerToString(curr_cpu_nmuber) cat ".dat";
      name2:="badprimes_weight" cat IntegerToString(weight_k) cat"_module" cat IntegerToString(l) cat "cpu_"cat IntegerToString(curr_cpu_nmuber) cat ".dat";
      name3:="goodprimes_weight"cat IntegerToString(weight_k) cat "_module" cat IntegerToString(l) cat "cpu_"cat IntegerToString(curr_cpu_nmuber) cat ".dat";			
      filept:=Open(name1,"r");
      filebadprime:=Open(name2,"r");	
      filegodprime:=Open(name3,"r");

      while true do
        prm := Gets(filept);
      	if IsEof(prm) then       	   
      	   break;
      	end if;         
        Primes:=Append( Primes,StringToInteger(prm) );        		  		        
      end while;
      delete filept;
            
      while true do
         prm:=Gets(filebadprime);
         if IsEof(prm) then break;end if;
         Badprimes:=Append( Badprimes,StringToInteger(prm) );
         
         prm:=Gets(filebadprime);
         if IsEof(prm) then break;end if;
         eBadprimes:=Append( eBadprimes,StringToInteger(prm) );         			
      end while;
      delete filebadprime;
    	"================= BEGIN ============================";	
      "begin reading a good prime from file";
    		
      while true do
         prm:=Gets(filegodprime);
         if IsEof(prm) then error"finish good primes exit";break;end if;
         tmp_p:=StringToInteger(prm);
         
         prm:=Gets(filegodprime);
         if IsEof(prm) then error"finish good primes exit";break;end if;
         tmp_e:=StringToInteger(prm);
         	         		
         if (tmp_p in Badprimes eq false) and (tmp_p in Primes eq false) then// this is the first prime want to perform
         	  p:=tmp_p;
         	  extdg:=tmp_e;         	  		         	  	
         	  break;	
         end if;		         		
      end while;    		
      delete filegodprime;
      
     "good Primes are",Primes;
     "bad primes are",Badprimes; 
      
     time tf:=Jacl(<Mod_As,p,extdg,weight_k,l,index>,<pis,phis>,computation_nr,CorrOfCusps);
     "total time used(above)";  
     "================= END  ============================";  
 end while;
       	
end function; 

/////////////////////////////////////////////////////////////////////////////

function checkV(FxFxyF,OandE,p_l)//Fx::FldFunRat,Fxy::FldFun,F::FldFin
//{check the ramanujan subspace Vl,OandE=<O,E1,E2>,sigma^k(Ei) belongs to Vl}
 p:=p_l[1];
 l:=p_l[2];
 
 O:=OandE[1];	
 E1:=OandE[2];
 E2:=OandE[3];		
  	
 Fx:=FxFxyF[1];
 Fxy:=FxFxyF[2];		
 F:=FxFxyF[3];
 N:=#F;
 				
 if IsPrincipal( l*E1 ) eq false  or IsPrincipal( l*E2 ) eq false then 
 	error"problem with ramanujan space!";
 end if;
 	 	
 Dtilde,rdg,Advr,aele:=Reduction(E1, O);				

 Ps,Es:=Support(Dtilde);

 SigmaE:=rdg*O;
 	
 for kk:=1 to #Ps do
    dofplc:=Degree(Ps[kk]);

    u,v:=PlaceToPoint(F,Ps[kk]);
    	
    ptset:=<<u,v>>;
    for ii:=1 to 	dofplc-1 do
    	 Append(~ptset,<u^(N^ii),v^(N^ii)>);
    end for;
		
    if PointSetToPlace(FxFxyF,ptset) ne Ps[kk] then
       	  			error"why it happens?!";
    end if;
    delete ptset;

    ptset:=<<u^p,v^p>>;
    for ii:=1 to 	dofplc-1 do
    	 Append(~ptset,<(u^(N^ii))^p,(v^(N^ii))^p>);
    end for;	
    	
    P:=PointSetToPlace(FxFxyF,ptset); 	
    SigmaE:=SigmaE+Es[kk]*P;

 end for;

 flagbetaafa:=0;	
 for beta:=0 to l-1 do
  		for afa:=0 to l-1 do               				  				
 			  if IsPrincipal(SigmaE-(beta*E1+afa*E2)) eq true then
 			  					flagbetaafa:=1;
 			  					break;	
 			  end if;
 		end for;
 		if flagbetaafa eq 1 then break;end if;
 end for;	 	
 
 if flagbetaafa eq 0 then error"sigma(E1) doesn't belong to Vl";end if;
 return true;
end function;

////////////////////////////////////////////////////////////////////

function dDivisor(FxFxyF,Cusps,Dvr,p_q_l,d,Horbits)
//{<d>(dvr)}
  
  O:=Divisor( Cusps[1] );
		
	noncusppart:=1*Dvr[1];
	
	cuspspart:=Dvr[3]*Dvr[2];
			
  //cuspspart,noncusppart:=SeperateCusp(Cusps,Dvr);
  
  Dvr1:=O-O;
  supp1,exps1:=Support(noncusppart);
  for i:=1 to #supp1 do
  	  if  IsFinite(supp1[i]) eq false then
  	  	"infinite place in divisor"; 
  	  	return false,<0,0,0>; 
  	  end if;	
  		tf,dimoadP:=dPlace(FxFxyF,p_q_l,supp1[i],d);
  		Dvr1:=Dvr1+1*dimoadP;	
  end for;
  
  Dvr2:=diamondcusp(Cusps,cuspspart,p_q_l[4],d,Horbits);
  
  D:=Dvr1+Dvr2;
  	
  Dtilde,rdg,Advr,aele:=Reduction(D, O);
  	
  return true,<Dtilde,O,rdg>;				
  
end function;

/////////////////////////////////////////////////////////////////////////////////////

/*
  Given Elliptic curve E over F_q and l-isogeny curve's j-invariant jp over F_q
  compute the isogeny curve F1 over F_q such that
  E isogeny to F1 over F_q
  output then isogeny curve's weiestress equation.

  source copy from magma m_isogenies.m
*/
function IsogenyCurveFromEjpl(E,jp,l)
/*
{
    source copy from magma m_isogenies.m
}
*/
    K := BaseRing(E);
    Kring:=PolynomialRing(K,2);
    Kring;
    p:=l;
    j_p:=jp;
    Phi:=Kring!ClassicalModularEquation(l);
    j:=jInvariant(E);

    error if Characteristic(K) in {2,3}, "Argument 1 must be defined over a field of characteristic other than 2 or 3.";


   E1, m1 := WeierstrassModel(E);
    _, _, _, a4, a6 := Explode(aInvariants(E1));

    E4, E6 := Explode(cInvariants(E));
    error if j eq 0,
	"Domain curve must not have j-invariant 0.";
    error if j eq 12^3,
	"Domain curve must not have j-invariant 12^3.";
    error if j_p eq 0,
	"Codomain curve must not have j-invariant 0.";
    error if j_p eq 12^3,
	"Codomain curve must not have j-invariant 12^3.";
    error if Characteristic(BaseRing(E)) in {2,3},
	"Argument 1 must be defined over a field " *
	"of characteristic different from 2 and 3.";

    P2 := Parent(Phi);
    X := P2.1; Y := P2.2;
    DxPhi := Derivative(Phi, X);

    DxPhiJJ := Evaluate(DxPhi, [j,j_p]);
    DyPhiJJ := Evaluate(DxPhi, [j_p,j]);
    error if DyPhiJJ eq 0,
        "Argument 1 must not be a singularity of curve model.";

    j_prime := -E6*j/E4;
    j_p_prime := -j_prime*DxPhiJJ/(p*DyPhiJJ);

    lambda := -j_p_prime/j_p;
    E4_p := lambda^2*j_p/(j_p-12^3);
    E6_p := lambda*E4_p;

    DxxPhi := Derivative(DxPhi, X);
    DxyPhi := Derivative(DxPhi, Y);

    DxxPhiJJ := Evaluate(DxxPhi, [j,j_p]);
    DxyPhiJJ := Evaluate(DxyPhi, [j,j_p]);
    DyyPhiJJ := Evaluate(DxxPhi, [j_p,j]);

    j_pp := -( j_prime^2*DxxPhiJJ +
               2*p*j_prime*j_p_prime*DxyPhiJJ +
               p^2*j_p_prime^2*DyyPhiJJ ) / (j_prime*DxPhiJJ);
    c2 := 6*j_pp + (3*E4^3 + 4*E6^2)/(E4*E6)
	         - p * (3*E4_p^3 + 4*E6_p^2)/(E4_p*E6_p);

    F1 := EllipticCurve([-p^4*E4_p/48,-p^6*E6_p/864]);

    return F1;
end function;

//////////////////////////////////////////////////////////////////

function Isogenymaps(E,psi,l)
/*
{ Input origin elliptic curve E,polynomial defining isogeny kerenel psi, and the degree of the isogeny
  ouput maps of the isogeny, phix,omegaxy;
}
*/

	R := BaseRing(E);
	S<x>:=Parent(psi);
	
	T<y>:=PolynomialRing(S);

	if Characteristic(R) eq 2 then error "error occuring! the characteristic of the base field should not equal 2";end if;
	
	if (l mod 2) eq 0 then error "error occuring! the degree of the isogeny should not be even";end if;
	
  a1,a2,a3,a4,a6 := Explode(aInvariants(E)); 
  b2,b4,b6 := Explode(bInvariants(E)); 

	r:=Degree(psi);
	s1:=-Coefficient(psi,r-1);
	dpsi:=Derivative(psi);
	ddpsi:=Derivative(dpsi);

	phix:=(4*x^3+b2*x^2+2*b4*x+b6)*(dpsi^2-ddpsi*psi)-(6*x^2+b2*x+b4)*dpsi*psi+(l*x-2*s1)*psi^2;
	
	psi2:=2*y+a1*x+a3;
	
	dphix:=Derivative(phix);

	omegaxy:=dphix*psi*psi2/2-phix*dpsi*psi2-(a1*phix+a3*psi^2)*psi/2;

	return <phix,omegaxy>;

end function;

////////////////////////////////////////////////////////////////////////////////////////

function VeluTargetCurve(E0,psi0)
//{compute the isogeny curve using velu s formulae}
   // Returns codomain E1 of the isogeny of Velu, defined with 
   // respect to the monic kernel polynomial psi0.} 

   R := BaseRing(E0); 
   //F := FunctionField(R);
   a1,a2,a3,a4,a6 := Explode(aInvariants(E0)); 
   b2,b4,b6 := Explode(bInvariants(E0)); 
   Psi0 := psi0;//Numerator(F!Eltseq(psi0)[1]);
   //Psi0;
   //F!Eltseq(psi0);
   S := Parent(Psi0); X := S.1;
   Psi2 := 4*X^3 + b2*X^2 + 2*b4*X + b6; // a polynomial. 
   r := Degree(Psi0); 
   e := Degree(GCD(Psi2,Psi0)); 
   N := 2*r + e + 1;  
   s1 := -Coefficient(Psi0,r-1); 
   s2 := R!0; s3 := R!0; 
   if r ge 3 then 
      s2 := Coefficient(Psi0,r-2);  
      s3 := -Coefficient(Psi0,r-3); 
   elif r ge 2 then  
      s2 := Coefficient(Psi0,r-2);  
   end if; 
   a1,a2,a3,a4,a6 := Explode(aInvariants(E0)); 
   b2,b4,b6,b8 := Explode(bInvariants(E0)); 
   p1 := s1; p2 := s1^2 - 2*s2; p3 := s1^3 - 3*s1*s2 + 3*s3; 
   t0 := 6*p2 + b2*p1 + r*b4; 
   w0 := 10*p3 + 2*b2*p2 + 3*b4*p1 + r*b6; 
   if (N mod 2) eq 1 then 
      E1 := EllipticCurve([a1,a2,a3,a4 - 5*t0,a6 - b2*t0 - 7*w0]); 
   else  
      E1 := EllipticCurve([a1,a2,a3,a4 - 5*t0/2,a6 - b2*t0/2 - 7*w0/2]); 
   end if; 
   	if IsSingular(E1) eq true then error "error occur!" ;end if;
   return E1; 
end function;

/////////////////////////////////////////////////////////////////////////////////////////////

function PsiKernel(E,l)
//{computing defining polynomials of l+1 cyclic sbgps of E[l]}	

	K:=BaseRing(E);

	PRE<x> := PolynomialRing(K);
	//PRE;
	//"K",K;
	//"E",E;
	/*
	NumOfE:=Order(E);
	ord_l:=	Valuation(NumOfE,l);
	//"NumOfE",NumOfE;
	if ord_l lt 2 then
		"NumOfE",NumOfE; 
		"l",l;
		"ord_l=",ord_l; 
		error "the cardinality should be divided by l^2"; 
	end if;
	*/
	//elements of E[l]
	Oinf:=E![0,1,0];
	 //"s1",Cputime();	
	ltorset:=DivisionPoints(Oinf,l);//time cuslting
	 //"s2",Cputime();	
	if 	#ltorset ne l^2 then error"#E[l] is not equal to l^2 !";end if;
		
	i:=1;
	while true do
	    pt0:=ltorset[i];
	    if pt0 ne Oinf then 
	    	break;
	    end if;
	    i:=i+1;		 
	end while;
	
	setpt0:=[i*pt0: i in [0..l-1]];
	
	i:=1;			
	while true do
	  pt1:=ltorset[i];
	  if (pt1 in setpt0) eq false then 
	    	break;
	  end if;
	  i:=i+1;	
	end while;
		
	 //"s3",Cputime();
	//end of finding a base
	
	//"------------- t3-----------------------------";
	//"pt0=",pt0;
	//"pt1",pt1;
	if IsOrder(pt0,l) eq false then error"pt0 is not of order l";end if;
	if IsOrder(pt1,l) eq false then error"pt1 is not of order l";end if;	
	 //Cputime();
	psi:=<x:i in [1..l+1]>;
        //enumerate all l+1 cyclic sbgps of order l
        
  if l eq 2 then
  	  psi[1]:=(x-pt0[1]);
  	  psi[2]:=(x-pt1[1]);
  	  tmp:=pt0+pt1;	
  	  psi[3]:=(x-tmp[1]);		
  else	      
	    for i in [1..l+1] do
	       //"i=",i;  		
	       psi[i]:=x-x+1;
	       if i eq 1 then 
	            for j:=1 to (l-1)div 2  do    
	    	  				tmp:=j*pt0;
          				psi[i]:=psi[i]*(x-tmp[1]);
	    				end for;
	       else
	            for j:=1 to (l-1)div 2  do    
	    	  					tmp:=j*(i*pt0+pt1);
                    psi[i]:=psi[i]*(x-tmp[1]);
	    				end for;		
	       end if;
	    end for;
	end if;
	//end of computing defining polynomials

// "s4",Cputime();
	return psi;

end function;

////////////////////////////////////////////////////////////////////////////////////////////////////////

function SameData(data)
//{if there exists same number in data then return false else return true}
	
	
	for i:=1 to #data do
		 for j:=i+1 to #data do
		 	  if data[i] eq data[j] then
		 	  	 return false;
		 	  end if;	
		 	end for;
	end for;
	return true;	
end function;

//////////////////////////////////////////////////////////////////////////////////////////////////////

function InTFPosition(a,S)
/*
{check if a is in the sequence S, if it is ture the return true and the position
	otherwise ruturn false and 0
	}
*/	

  tf:=false;
  n:=0;	
	for i:=1 to #S do
    if a eq S[i] then
    	 tf:=true;
    	 	n:=i;
    	 	break;
    end if; 
  end for;
  
  if tf then return true,n;
  else return false,0;
  end if;	
end function;

//////////////////////////////////////////////////////////////////////////////////////

function RecoverPolys()
/*
{try to recover the polynomial Q_x_weight(k)_level(l) from V_l mod p conputed,
file_nu is the numbers of k of proj_poly_cpu_(k).dat computed}
*/
    
    l:=XHldata()[2][2];

    file_nu:=[1,2,3,4,5,6,7,8];
    		
    //======================== recovering the polynomial corresponding to the projective  rep.
    Primes:=[];
    Cis:=[];
    	
    DegreeofFX:=l+1;
    //read polynomials (projective)
    	
   for k in  file_nu do
    fname1:="proj_poly"cat IntegerToString(l) cat"_cpu" cat IntegerToString(k)cat ".dat";
				    		
    filept1:=Open(fname1,"r");					
			    	
    while true do
            prm := Gets(filept1);
              
    	      if IsEof(prm) then break;end if;
             
            	Append(~Primes,StringToInteger(prm) );
            	
            	ds:=[];	
            	for i:=0 to DegreeofFX do 
            		tmp:=Gets(filept1);
            		
            		Append(~ds,StringToInteger(tmp));	
            		delete tmp;	
            	end for;        	
            	Append(~Cis,ds);
            	delete ds;  		  		  		        
    end while;
		
    delete filept1;
   end for;
    
    //=============================================//
    
    pol<u>:=PolynomialRing(IntegerRing());
    
    "good Primes in file",Primes;
    //"total number of primes",#Primes;
    
    for i:=1 to #Primes do
    	for j:=i+1 to #Primes do
    		 if Primes[i] eq Primes[j] then
    		 	"i",i,"j",j,"p",Primes[i];
    		 	error"same prime in file!!!";
    		 end if;	 
    	end for;
    end for;
        			           
    crtcs:=[];
    
    for j:=1 to DegreeofFX+1 do//00
    	
    	tmp:=[];
    		
    	for i:=1 to #Cis do
    		Append(~tmp,Cis[i][j]);	
    	end for;
    	
    	Append(~crtcs,tmp);
    	delete tmp;
    	
    end for;//00

    outfname1:="proj_poly"cat IntegerToString(l) cat".txt";
    outfilept1:=Open(outfname1,"w");	
    	    
    //find the shortest vector a_i/b_i = x_i mod p_i
    M:=1;
    for i:=1 to #Primes do
    		M:=M*Primes[i];
    end for;	 
    //"M=",M;
    "Log10(M)=",Log(M)/Log(10);
    "number of primes ",#Primes;
    FFLG:=0;
    
    Mring:=Integers(M);
    Deo:=[];
    Num:=[];
    tfall:=true;			
    for i:=1 to DegreeofFX+1 do
    	 j:=DegreeofFX+1+1-i;
    	 //"crtcs[j]=",crtcs[j];
    	 //"CRT(crtcs[j],Primes)=",CRT(crtcs[j],Primes);	
    	 tf,adivb:=RationalReconstruction(Mring!(CRT(crtcs[j],Primes)));
    	 	
    	 if tf eq false then 
    	 	"j=",j,"need double the precision while recovering the proj poly";
    	 	FFLG:=1;
    	 	tfall:=false;
    	 	break;	
    	 end if;
    	 	Append(~Deo,Denominator(adivb));
    	 	Append(~Num,Numerator(adivb));	
    	 "j",j;
    	 //"a/b",adivb;
    end for;
    
    if tfall then
       totaldeo:=LCM(Deo);
              	       
       Fu:=pol!0;
       for i:=1 to DegreeofFX+1 do
       	tf,adivb:=RationalReconstruction(Mring!(CRT(crtcs[i],Primes)));
       	Fu:=Fu+u^(i-1)*	Numerator(adivb)*(totaldeo div Denominator(adivb) );
       	if i ne DegreeofFX+1 then
       			
       		fprintf outfilept1,"%o\n",Numerator(adivb)*(totaldeo div Denominator(adivb) ),i-1;	       	
       	else
       		fprintf outfilept1,"%o\n",Numerator(adivb)*(totaldeo div Denominator(adivb) ),i-1;	       		
       	end if;	
       	
       end for;
       delete outfilept1;
    end if; 
    if FFLG eq 0 then "projective polynomial recovered!!";end if;
    	
 return true;
end 	function; 

//////////////////////////////////////////////////

function RecoverFaithPolys()
/*
{try to recover the polynomial P_x_weight(k)_level(l) from V_l mod p computed,
file_nu is the numbers of k of fait_poly_cpu_(k).dat computed}
*/
    
    l:=XHldata()[2][2];

    file_nu:=[1,2,3,4,5,6,7,8];
    		
    //======================== recovering the polynomial corresponding to the projective  rep.
    Primes:=[];
    Cis:=[];
    	
    DegreeofFX:=(l+1)*2^Valuation(l-1,2);
    //read polynomials (entire)
    	
   for k in  file_nu do
    fname1:="fait_poly"cat IntegerToString(l) cat"_cpu" cat IntegerToString(k)cat ".dat";
				    		
    filept1:=Open(fname1,"r");					
			    	
    while true do
            prm := Gets(filept1);
              
    	      if IsEof(prm) then break;end if;
             
            	Append(~Primes,StringToInteger(prm) );
            	
            	ds:=[];	
            	for i:=0 to DegreeofFX do 
            		tmp:=Gets(filept1);
            		
            		Append(~ds,StringToInteger(tmp));	
            		delete tmp;	
            	end for;        	
            	Append(~Cis,ds);
            	delete ds;  		  		  		        
    end while;
		
    delete filept1;
   end for;
    
    //=============================================//
    
    pol<u>:=PolynomialRing(IntegerRing());
    
    "good Primes in file",Primes;
    //"total number of primes",#Primes;
    
    for i:=1 to #Primes do
    	for j:=i+1 to #Primes do
    		 if Primes[i] eq Primes[j] then
    		 	"i",i,"j",j,"p",Primes[i];
    		 	error"same prime in file!!!";
    		 end if;	 
    	end for;
    end for;
        			           
    crtcs:=[];
    
    for j:=1 to DegreeofFX+1 do//00
    	
    	tmp:=[];
    		
    	for i:=1 to #Cis do
    		Append(~tmp,Cis[i][j]);	
    	end for;
    	
    	Append(~crtcs,tmp);
    	delete tmp;
    	
    end for;//00

    outfname1:="fait_poly"cat IntegerToString(l) cat".txt";
    outfilept1:=Open(outfname1,"w");	
    	    
    //find the shortest vector a_i/b_i = x_i mod p_i
    M:=1;
    for i:=1 to #Primes do
    		M:=M*Primes[i];
    end for;	 
    //"M=",M;
    "Log10(M)=",Log(M)/Log(10);
    "number of primes ",#Primes;
    FFLG:=0;
    
    Mring:=Integers(M);
    Deo:=[];
    Num:=[];
    tfall:=true;			
    for i:=1 to DegreeofFX+1 do
    	 j:=DegreeofFX+1+1-i;
    	 //"crtcs[j]=",crtcs[j];
    	 //"CRT(crtcs[j],Primes)=",CRT(crtcs[j],Primes);	
    	 tf,adivb:=RationalReconstruction(Mring!(CRT(crtcs[j],Primes)));
    	 	
    	 if tf eq false then 
    	 	"j=",j,"need double the precision while recovering the entire poly";
    	 	FFLG:=1;
    	 	tfall:=false;
    	 	break;	
    	 end if;
    	 	Append(~Deo,Denominator(adivb));
    	 	Append(~Num,Numerator(adivb));	
    	 "j",j;
    	 //"a/b",adivb;
    end for;
    
    if tfall then
       totaldeo:=LCM(Deo);
              	       
       Fu:=pol!0;
       for i:=1 to DegreeofFX+1 do
       	tf,adivb:=RationalReconstruction(Mring!(CRT(crtcs[i],Primes)));
       	Fu:=Fu+u^(i-1)*	Numerator(adivb)*(totaldeo div Denominator(adivb) );
       	if i ne DegreeofFX+1 then
       			
       		fprintf outfilept1,"%o\n",Numerator(adivb)*(totaldeo div Denominator(adivb) ),i-1;	       	
       	else
       		fprintf outfilept1,"%o\n",Numerator(adivb)*(totaldeo div Denominator(adivb) ),i-1;	       		
       	end if;	
       	
       end for;
       delete outfilept1;
    end if; 
    if FFLG eq 0 then "entire polynomial recovered!!";end if;
    	
 return true;
end 	function; 

//////////////////////////////////////////////////
